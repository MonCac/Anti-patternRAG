{
  "antipattern_type": "CH",
  "project_name": "kafka",
  "commit_number": "commit_1000",
  "id": "158",
  "group_id": 1,
  "chunks": [
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\CH\\apache\\kafka\\commit_1000\\158\\before\\clients/src/main/java/org/apache/kafka/common/requests/AbstractRequest.java",
      "chunk_type": "superClass",
      "ast_subtree": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.errors.UnsupportedVersionException;\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.ObjectSerializationCache;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Map;\n\npublic abstract class AbstractRequest implements AbstractRequestResponse {\n\n    public abstract static class Builder<T extends AbstractRequest> {\n        private final ApiKeys apiKey;\n        private final short oldestAllowedVersion;\n        private final short latestAllowedVersion;\n\n        /**\n         * Construct a new builder which allows any supported version\n         */\n        public Builder(ApiKeys apiKey, boolean enableUnstableLastVersion) {\n            this(apiKey, apiKey.oldestVersion(), apiKey.latestVersion(enableUnstableLastVersion));\n        }\n\n        /**\n         * Construct a new builder which allows any supported and released version\n         */\n        public Builder(ApiKeys apiKey) {\n            this(apiKey, false);\n        }\n\n        /**\n         * Construct a new builder which allows only a specific version\n         */\n        public Builder(ApiKeys apiKey, short allowedVersion) {\n            this(apiKey, allowedVersion, allowedVersion);\n        }\n\n        /**\n         * Construct a new builder which allows an inclusive range of versions\n         */\n        public Builder(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {\n            this.apiKey = apiKey;\n            this.oldestAllowedVersion = oldestAllowedVersion;\n            this.latestAllowedVersion = latestAllowedVersion;\n        }\n\n        public ApiKeys apiKey() {\n            return apiKey;\n        }\n\n        public short oldestAllowedVersion() {\n            return oldestAllowedVersion;\n        }\n\n        public short latestAllowedVersion() {\n            return latestAllowedVersion;\n        }\n\n        public T build() {\n            return build(latestAllowedVersion());\n        }\n\n        public abstract T build(short version);\n    }\n\n    private final short version;\n    private final ApiKeys apiKey;\n\n    public AbstractRequest(ApiKeys apiKey, short version) {\n        if (!apiKey.isVersionSupported(version))\n            throw new UnsupportedVersionException(\"The \" + apiKey + \" protocol does not support version \" + version);\n        this.version = version;\n        this.apiKey = apiKey;\n    }\n\n    /**\n     * Get the version of this AbstractRequest object.\n     */\n    public short version() {\n        return version;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    public final Send toSend(RequestHeader header) {\n        return SendBuilder.buildRequestSend(header, data());\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    public final ByteBuffer serializeWithHeader(RequestHeader header) {\n        if (header.apiKey() != apiKey) {\n            throw new IllegalArgumentException(\"Could not build request \" + apiKey + \" with header api key \" + header.apiKey());\n        }\n        if (header.apiVersion() != version) {\n            throw new IllegalArgumentException(\"Could not build request version \" + version + \" with header version \" + header.apiVersion());\n        }\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    public final ByteBuffer serialize() {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    // Visible for testing\n    final int sizeInBytes() {\n        return data().size(new ObjectSerializationCache(), version);\n    }\n\n    public String toString(boolean verbose) {\n        return data().toString();\n    }\n\n    @Override\n    public final String toString() {\n        return toString(true);\n    }\n\n    /**\n     * Get an error response for a request\n     */\n    public AbstractResponse getErrorResponse(Throwable e) {\n        return getErrorResponse(AbstractResponse.DEFAULT_THROTTLE_TIME, e);\n    }\n\n    /**\n     * Get an error response for a request with specified throttle time in the response if applicable\n     */\n    public abstract AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e);\n\n    /**\n     * Get the error counts corresponding to an error response. This is overridden for requests\n     * where response may be null (e.g produce with acks=0).\n     */\n    public Map<Errors, Integer> errorCounts(Throwable e) {\n        AbstractResponse response = getErrorResponse(0, e);\n        if (response == null)\n            throw new IllegalStateException(\"Error counts could not be obtained for request \" + this);\n        else\n            return response.errorCounts();\n    }\n\n    /**\n     * Factory method for getting a request object based on ApiKey ID and a version\n     */\n    public static RequestAndSize parseRequest(ApiKeys apiKey, short apiVersion, ByteBuffer buffer) {\n        int bufferSize = buffer.remaining();\n        return new RequestAndSize(doParseRequest(apiKey, apiVersion, buffer), bufferSize);\n    }\n\n    private static AbstractRequest doParseRequest(ApiKeys apiKey, short apiVersion, ByteBuffer buffer) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceRequest.parse(buffer, apiVersion);\n            case FETCH:\n                return FetchRequest.parse(buffer, apiVersion);\n            case LIST_OFFSETS:\n                return ListOffsetsRequest.parse(buffer, apiVersion);\n            case METADATA:\n                return MetadataRequest.parse(buffer, apiVersion);\n            case OFFSET_COMMIT:\n                return OffsetCommitRequest.parse(buffer, apiVersion);\n            case OFFSET_FETCH:\n                return OffsetFetchRequest.parse(buffer, apiVersion);\n            case FIND_COORDINATOR:\n                return FindCoordinatorRequest.parse(buffer, apiVersion);\n            case JOIN_GROUP:\n                return JoinGroupRequest.parse(buffer, apiVersion);\n            case HEARTBEAT:\n                return HeartbeatRequest.parse(buffer, apiVersion);\n            case LEAVE_GROUP:\n                return LeaveGroupRequest.parse(buffer, apiVersion);\n            case SYNC_GROUP:\n                return SyncGroupRequest.parse(buffer, apiVersion);\n            case STOP_REPLICA:\n                return StopReplicaRequest.parse(buffer, apiVersion);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownRequest.parse(buffer, apiVersion);\n            case UPDATE_METADATA:\n                return UpdateMetadataRequest.parse(buffer, apiVersion);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrRequest.parse(buffer, apiVersion);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsRequest.parse(buffer, apiVersion);\n            case LIST_GROUPS:\n                return ListGroupsRequest.parse(buffer, apiVersion);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeRequest.parse(buffer, apiVersion);\n            case API_VERSIONS:\n                return ApiVersionsRequest.parse(buffer, apiVersion);\n            case CREATE_TOPICS:\n                return CreateTopicsRequest.parse(buffer, apiVersion);\n            case DELETE_TOPICS:\n                return DeleteTopicsRequest.parse(buffer, apiVersion);\n            case DELETE_RECORDS:\n                return DeleteRecordsRequest.parse(buffer, apiVersion);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdRequest.parse(buffer, apiVersion);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochRequest.parse(buffer, apiVersion);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnRequest.parse(buffer, apiVersion);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnRequest.parse(buffer, apiVersion);\n            case END_TXN:\n                return EndTxnRequest.parse(buffer, apiVersion);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersRequest.parse(buffer, apiVersion);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitRequest.parse(buffer, apiVersion);\n            case DESCRIBE_ACLS:\n                return DescribeAclsRequest.parse(buffer, apiVersion);\n            case CREATE_ACLS:\n                return CreateAclsRequest.parse(buffer, apiVersion);\n            case DELETE_ACLS:\n                return DeleteAclsRequest.parse(buffer, apiVersion);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsRequest.parse(buffer, apiVersion);\n            case ALTER_CONFIGS:\n                return AlterConfigsRequest.parse(buffer, apiVersion);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsRequest.parse(buffer, apiVersion);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsRequest.parse(buffer, apiVersion);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateRequest.parse(buffer, apiVersion);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsRequest.parse(buffer, apiVersion);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenRequest.parse(buffer, apiVersion);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenRequest.parse(buffer, apiVersion);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenRequest.parse(buffer, apiVersion);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenRequest.parse(buffer, apiVersion);\n            case DELETE_GROUPS:\n                return DeleteGroupsRequest.parse(buffer, apiVersion);\n            case ELECT_LEADERS:\n                return ElectLeadersRequest.parse(buffer, apiVersion);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsRequest.parse(buffer, apiVersion);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsRequest.parse(buffer, apiVersion);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsRequest.parse(buffer, apiVersion);\n            case OFFSET_DELETE:\n                return OffsetDeleteRequest.parse(buffer, apiVersion);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasRequest.parse(buffer, apiVersion);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasRequest.parse(buffer, apiVersion);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsRequest.parse(buffer, apiVersion);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsRequest.parse(buffer, apiVersion);\n            case VOTE:\n                return VoteRequest.parse(buffer, apiVersion);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochRequest.parse(buffer, apiVersion);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochRequest.parse(buffer, apiVersion);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumRequest.parse(buffer, apiVersion);\n            case ALTER_PARTITION:\n                return AlterPartitionRequest.parse(buffer, apiVersion);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesRequest.parse(buffer, apiVersion);\n            case ENVELOPE:\n                return EnvelopeRequest.parse(buffer, apiVersion);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotRequest.parse(buffer, apiVersion);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterRequest.parse(buffer, apiVersion);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersRequest.parse(buffer, apiVersion);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationRequest.parse(buffer, apiVersion);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatRequest.parse(buffer, apiVersion);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerRequest.parse(buffer, apiVersion);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsRequest.parse(buffer, apiVersion);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsRequest.parse(buffer, apiVersion);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsRequest.parse(buffer, apiVersion);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatRequest.parse(buffer, apiVersion);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeRequest.parse(buffer, apiVersion);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationRequest.parse(buffer, apiVersion);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsRequest.parse(buffer, apiVersion);\n            case PUSH_TELEMETRY:\n                return PushTelemetryRequest.parse(buffer, apiVersion);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsRequest.parse(buffer, apiVersion);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesRequest.parse(buffer, apiVersion);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsRequest.parse(buffer, apiVersion);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatRequest.parse(buffer, apiVersion);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeRequest.parse(buffer, apiVersion);\n            case SHARE_FETCH:\n                return ShareFetchRequest.parse(buffer, apiVersion);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeRequest.parse(buffer, apiVersion);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterRequest.parse(buffer, apiVersion);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterRequest.parse(buffer, apiVersion);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterRequest.parse(buffer, apiVersion);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateRequest.parse(buffer, apiVersion);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateRequest.parse(buffer, apiVersion);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateRequest.parse(buffer, apiVersion);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateRequest.parse(buffer, apiVersion);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryRequest.parse(buffer, apiVersion);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatRequest.parse(buffer, apiVersion);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeRequest.parse(buffer, apiVersion);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsRequest.parse(buffer, apiVersion);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseRequest`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n}\n"
    },
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\CH\\apache\\kafka\\commit_1000\\158\\before\\clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownRequest.java",
      "chunk_type": "subClass",
      "ast_subtree": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.message.ControlledShutdownRequestData;\nimport org.apache.kafka.common.message.ControlledShutdownResponseData;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\n\npublic class ControlledShutdownRequest extends AbstractRequest {\n\n    public static class Builder extends AbstractRequest.Builder<ControlledShutdownRequest> {\n\n        private final ControlledShutdownRequestData data;\n\n        public Builder(ControlledShutdownRequestData data, short desiredVersion) {\n            super(ApiKeys.CONTROLLED_SHUTDOWN, desiredVersion);\n            this.data = data;\n        }\n\n        @Override\n        public ControlledShutdownRequest build(short version) {\n            return new ControlledShutdownRequest(data, version);\n        }\n\n        @Override\n        public String toString() {\n            return data.toString();\n        }\n    }\n\n    private final ControlledShutdownRequestData data;\n\n    private ControlledShutdownRequest(ControlledShutdownRequestData data, short version) {\n        super(ApiKeys.CONTROLLED_SHUTDOWN, version);\n        this.data = data;\n    }\n\n    @Override\n    public ControlledShutdownResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n        ControlledShutdownResponseData data = new ControlledShutdownResponseData()\n                .setErrorCode(Errors.forException(e).code());\n        return new ControlledShutdownResponse(data);\n    }\n\n    public static ControlledShutdownRequest parse(ByteBuffer buffer, short version) {\n        return new ControlledShutdownRequest(new ControlledShutdownRequestData(new ByteBufferAccessor(buffer), version),\n            version);\n    }\n\n    @Override\n    public ControlledShutdownRequestData data() {\n        return data;\n    }\n}\n"
    }
  ]
}