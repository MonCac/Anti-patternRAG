{
  "antipattern_type": "CH",
  "project_name": "kafka",
  "commit_number": "commit_1000",
  "id": "77",
  "group_id": 5,
  "chunks": [
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\CH\\apache\\kafka\\commit_1000\\77\\before\\clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java",
      "chunk_type": "superClass",
      "ast_subtree": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic abstract class AbstractResponse implements AbstractRequestResponse {\n    public static final int DEFAULT_THROTTLE_TIME = 0;\n\n    private final ApiKeys apiKey;\n\n    protected AbstractResponse(ApiKeys apiKey) {\n        this.apiKey = apiKey;\n    }\n\n    public final Send toSend(ResponseHeader header, short version) {\n        return SendBuilder.buildResponseSend(header, data(), version);\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    final ByteBuffer serializeWithHeader(ResponseHeader header, short version) {\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    final ByteBuffer serialize(short version) {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    /**\n     * The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as\n     * more specifically scoped errors (such as topic or partition-level errors).\n     * @return A count of errors.\n     */\n    public abstract Map<Errors, Integer> errorCounts();\n\n    protected Map<Errors, Integer> errorCounts(Errors error) {\n        return Collections.singletonMap(error, 1);\n    }\n\n    protected Map<Errors, Integer> errorCounts(Stream<Errors> errors) {\n        return errors.collect(Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1)));\n    }\n\n    protected Map<Errors, Integer> errorCounts(Collection<Errors> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (Errors error : errors)\n            updateErrorCounts(errorCounts, error);\n        return errorCounts;\n    }\n\n    protected Map<Errors, Integer> apiErrorCounts(Map<?, ApiError> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (ApiError apiError : errors.values())\n            updateErrorCounts(errorCounts, apiError.error());\n        return errorCounts;\n    }\n\n    protected void updateErrorCounts(Map<Errors, Integer> errorCounts, Errors error) {\n        Integer count = errorCounts.getOrDefault(error, 0);\n        errorCounts.put(error, count + 1);\n    }\n\n    /**\n     * Parse a response from the provided buffer. The buffer is expected to hold both\n     * the {@link ResponseHeader} as well as the response payload.\n     */\n    public static AbstractResponse parseResponse(ByteBuffer buffer, RequestHeader requestHeader) {\n        ApiKeys apiKey = requestHeader.apiKey();\n        short apiVersion = requestHeader.apiVersion();\n\n        ResponseHeader responseHeader = ResponseHeader.parse(buffer, apiKey.responseHeaderVersion(apiVersion));\n\n        if (requestHeader.correlationId() != responseHeader.correlationId()) {\n            throw new CorrelationIdMismatchException(\"Correlation id for response (\"\n                + responseHeader.correlationId() + \") does not match request (\"\n                + requestHeader.correlationId() + \"), request header: \" + requestHeader,\n                requestHeader.correlationId(), responseHeader.correlationId());\n        }\n\n        return AbstractResponse.parseResponse(apiKey, buffer, apiVersion);\n    }\n\n    public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceResponse.parse(responseBuffer, version);\n            case FETCH:\n                return FetchResponse.parse(responseBuffer, version);\n            case LIST_OFFSETS:\n                return ListOffsetsResponse.parse(responseBuffer, version);\n            case METADATA:\n                return MetadataResponse.parse(responseBuffer, version);\n            case OFFSET_COMMIT:\n                return OffsetCommitResponse.parse(responseBuffer, version);\n            case OFFSET_FETCH:\n                return OffsetFetchResponse.parse(responseBuffer, version);\n            case FIND_COORDINATOR:\n                return FindCoordinatorResponse.parse(responseBuffer, version);\n            case JOIN_GROUP:\n                return JoinGroupResponse.parse(responseBuffer, version);\n            case HEARTBEAT:\n                return HeartbeatResponse.parse(responseBuffer, version);\n            case LEAVE_GROUP:\n                return LeaveGroupResponse.parse(responseBuffer, version);\n            case SYNC_GROUP:\n                return SyncGroupResponse.parse(responseBuffer, version);\n            case STOP_REPLICA:\n                return StopReplicaResponse.parse(responseBuffer, version);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownResponse.parse(responseBuffer, version);\n            case UPDATE_METADATA:\n                return UpdateMetadataResponse.parse(responseBuffer, version);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsResponse.parse(responseBuffer, version);\n            case LIST_GROUPS:\n                return ListGroupsResponse.parse(responseBuffer, version);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeResponse.parse(responseBuffer, version);\n            case API_VERSIONS:\n                return ApiVersionsResponse.parse(responseBuffer, version);\n            case CREATE_TOPICS:\n                return CreateTopicsResponse.parse(responseBuffer, version);\n            case DELETE_TOPICS:\n                return DeleteTopicsResponse.parse(responseBuffer, version);\n            case DELETE_RECORDS:\n                return DeleteRecordsResponse.parse(responseBuffer, version);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdResponse.parse(responseBuffer, version);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\n            case END_TXN:\n                return EndTxnResponse.parse(responseBuffer, version);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\n            case DESCRIBE_ACLS:\n                return DescribeAclsResponse.parse(responseBuffer, version);\n            case CREATE_ACLS:\n                return CreateAclsResponse.parse(responseBuffer, version);\n            case DELETE_ACLS:\n                return DeleteAclsResponse.parse(responseBuffer, version);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsResponse.parse(responseBuffer, version);\n            case ALTER_CONFIGS:\n                return AlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsResponse.parse(responseBuffer, version);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\n            case DELETE_GROUPS:\n                return DeleteGroupsResponse.parse(responseBuffer, version);\n            case ELECT_LEADERS:\n                return ElectLeadersResponse.parse(responseBuffer, version);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case OFFSET_DELETE:\n                return OffsetDeleteResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\n            case VOTE:\n                return VoteResponse.parse(responseBuffer, version);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION:\n                return AlterPartitionResponse.parse(responseBuffer, version);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\n            case ENVELOPE:\n                return EnvelopeResponse.parse(responseBuffer, version);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterResponse.parse(responseBuffer, version);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersResponse.parse(responseBuffer, version);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsResponse.parse(responseBuffer, version);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\n            case PUSH_TELEMETRY:\n                return PushTelemetryResponse.parse(responseBuffer, version);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\n            case SHARE_FETCH:\n                return ShareFetchResponse.parse(responseBuffer, version);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterResponse.parse(responseBuffer, version);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseResponse`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n\n    /**\n     * Returns whether or not client should throttle upon receiving a response of the specified version with a non-zero\n     * throttle time. Client-side throttling is needed when communicating with a newer version of broker which, on\n     * quota violation, sends out responses before throttling.\n     */\n    public boolean shouldClientThrottle(short version) {\n        return false;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    /**\n     * Get the throttle time in milliseconds. If the response schema does not\n     * support this field, then 0 will be returned.\n     */\n    public abstract int throttleTimeMs();\n\n    /**\n     * Set the throttle time in the response if the schema supports it. Otherwise,\n     * this is a no-op.\n     *\n     * @param throttleTimeMs The throttle time in milliseconds\n     */\n    public abstract void maybeSetThrottleTimeMs(int throttleTimeMs);\n\n    public String toString() {\n        return data().toString();\n    }\n}\n"
    },
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\CH\\apache\\kafka\\commit_1000\\77\\before\\clients/src/main/java/org/apache/kafka/common/requests/StopReplicaResponse.java",
      "chunk_type": "subClass",
      "ast_subtree": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.message.StopReplicaResponseData;\nimport org.apache.kafka.common.message.StopReplicaResponseData.StopReplicaPartitionError;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class StopReplicaResponse extends AbstractResponse {\n\n    /**\n     * Possible error code:\n     *  - {@link Errors#STALE_CONTROLLER_EPOCH}\n     *  - {@link Errors#STALE_BROKER_EPOCH}\n     *  - {@link Errors#FENCED_LEADER_EPOCH}\n     *  - {@link Errors#KAFKA_STORAGE_ERROR}\n     */\n    private final StopReplicaResponseData data;\n\n    public StopReplicaResponse(StopReplicaResponseData data) {\n        super(ApiKeys.STOP_REPLICA);\n        this.data = data;\n    }\n\n    public List<StopReplicaPartitionError> partitionErrors() {\n        return data.partitionErrors();\n    }\n\n    public Errors error() {\n        return Errors.forCode(data.errorCode());\n    }\n\n    @Override\n    public Map<Errors, Integer> errorCounts() {\n        if (data.errorCode() != Errors.NONE.code())\n            // Minor optimization since the top-level error applies to all partitions\n            return Collections.singletonMap(error(), data.partitionErrors().size() + 1);\n        Map<Errors, Integer> errors = errorCounts(data.partitionErrors().stream().map(p -> Errors.forCode(p.errorCode())));\n        updateErrorCounts(errors, Errors.forCode(data.errorCode())); // top level error\n        return errors;\n    }\n\n    public static StopReplicaResponse parse(ByteBuffer buffer, short version) {\n        return new StopReplicaResponse(new StopReplicaResponseData(new ByteBufferAccessor(buffer), version));\n    }\n\n    @Override\n    public int throttleTimeMs() {\n        return DEFAULT_THROTTLE_TIME;\n    }\n\n    @Override\n    public void maybeSetThrottleTimeMs(int throttleTimeMs) {\n        // Not supported by the response schema\n    }\n\n    @Override\n    public StopReplicaResponseData data() {\n        return data;\n    }\n\n    @Override\n    public String toString() {\n        return data.toString();\n    }\n\n}\n"
    }
  ]
}