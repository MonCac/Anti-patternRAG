{
  "antipattern_type": "AWD",
  "project_name": "hadoop",
  "commit_number": "commit_1200",
  "id": "2245",
  "group_id": 4,
  "chunks": [
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\AWD\\apache\\hadoop\\commit_1200\\2245\\before\\hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/snapshot/TestSnapshotDiffReport.java",
      "chunk_type": "clientClass",
      "ast_subtree": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode.snapshot;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Random;\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport org.apache.commons.collections.list.TreeList;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FSDataOutputStream;\nimport org.apache.hadoop.fs.Options.Rename;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.fs.RemoteIterator;\nimport org.apache.hadoop.hdfs.DFSConfigKeys;\nimport org.apache.hadoop.hdfs.DFSTestUtil;\nimport org.apache.hadoop.hdfs.DFSUtil;\nimport org.apache.hadoop.hdfs.DistributedFileSystem;\nimport org.apache.hadoop.hdfs.MiniDFSCluster;\nimport org.apache.hadoop.hdfs.client.HdfsDataOutputStream;\nimport org.apache.hadoop.hdfs.client.HdfsDataOutputStream.SyncFlag;\nimport org.apache.hadoop.hdfs.client.impl.SnapshotDiffReportGenerator;\nimport org.apache.hadoop.hdfs.protocol.SnapshotDiffReport;\nimport org.apache.hadoop.hdfs.protocol.SnapshotDiffReport.DiffReportEntry;\nimport org.apache.hadoop.hdfs.protocol.SnapshotDiffReport.DiffType;\nimport org.apache.hadoop.hdfs.protocol.SnapshotDiffReportListing;\nimport org.apache.hadoop.hdfs.protocol.SnapshotException;\nimport org.apache.hadoop.hdfs.server.namenode.INodeDirectory;\nimport org.apache.hadoop.hdfs.server.namenode.NameNode;\nimport org.apache.hadoop.hdfs.server.namenode.NameNodeAdapter;\nimport org.apache.hadoop.test.GenericTestUtils;\nimport org.apache.hadoop.util.ChunkedArrayList;\nimport org.apache.hadoop.util.Time;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Assume;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Tests snapshot deletion.\n */\npublic class TestSnapshotDiffReport {\n  private static final Logger LOG =\n      LoggerFactory.getLogger(TestSnapshotDiffReport.class);\n  private static final long SEED = 0;\n  private static final short REPLICATION = 3;\n  private static final short REPLICATION_1 = 2;\n  private static final long BLOCKSIZE = 1024;\n  private static final long BUFFERLEN = BLOCKSIZE / 2;\n  private static final long FILELEN = BLOCKSIZE * 2;\n\n  private final Path dir = new Path(\"/TestSnapshot\");\n  private final Path sub1 = new Path(dir, \"sub1\");\n  \n  protected Configuration conf;\n  protected MiniDFSCluster cluster;\n  protected DistributedFileSystem hdfs;\n  private final HashMap<Path, Integer> snapshotNumberMap = new HashMap<Path, Integer>();\n\n  @Before\n  public void setUp() throws Exception {\n    conf = new Configuration();\n    conf.setBoolean(\n        DFSConfigKeys.DFS_NAMENODE_SNAPSHOT_CAPTURE_OPENFILES, true);\n    conf.setLong(DFSConfigKeys.DFS_NAMENODE_ACCESSTIME_PRECISION_KEY, 1);\n    conf.setBoolean(\n        DFSConfigKeys.DFS_NAMENODE_SNAPSHOT_SKIP_CAPTURE_ACCESSTIME_ONLY_CHANGE,\n        true);\n    conf.setBoolean(\n        DFSConfigKeys.DFS_NAMENODE_SNAPSHOT_DIFF_ALLOW_SNAP_ROOT_DESCENDANT,\n        true);\n    conf.setInt(DFSConfigKeys.DFS_NAMENODE_SNAPSHOT_DIFF_LISTING_LIMIT, 3);\n    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION)\n        .format(true).build();\n    cluster.waitActive();\n    hdfs = cluster.getFileSystem();\n  }\n\n  @After\n  public void tearDown() throws Exception {\n    if (cluster != null) {\n      cluster.shutdown();\n      cluster = null;\n    }\n  }\n\n  protected Path getSnapRootDir() {\n    return sub1;\n  }\n\n  private String genSnapshotName(Path snapshotDir) {\n    int sNum = -1;\n    if (snapshotNumberMap.containsKey(snapshotDir)) {\n      sNum = snapshotNumberMap.get(snapshotDir);\n    }\n    snapshotNumberMap.put(snapshotDir, ++sNum);\n    return \"s\" + sNum;\n  }\n\n  /**\n   * Create/modify/delete files under a given directory, also create snapshots\n   * of directories.\n   */\n  protected void modifyAndCreateSnapshot(Path modifyDir, Path[] snapshotDirs)\n      throws Exception {\n    Path file10 = new Path(modifyDir, \"file10\");\n    Path file11 = new Path(modifyDir, \"file11\");\n    Path file12 = new Path(modifyDir, \"file12\");\n    Path file13 = new Path(modifyDir, \"file13\");\n    Path link13 = new Path(modifyDir, \"link13\");\n    Path file14 = new Path(modifyDir, \"file14\");\n    Path file15 = new Path(modifyDir, \"file15\");\n    DFSTestUtil.createFile(hdfs, file10, BLOCKSIZE, REPLICATION_1, SEED);\n    DFSTestUtil.createFile(hdfs, file11, BLOCKSIZE, REPLICATION_1, SEED);\n    DFSTestUtil.createFile(hdfs, file12, BLOCKSIZE, REPLICATION_1, SEED);\n    DFSTestUtil.createFile(hdfs, file13, BLOCKSIZE, REPLICATION_1, SEED);\n    // create link13\n    hdfs.createSymlink(file13, link13, false);\n    // create snapshot\n    for (Path snapshotDir : snapshotDirs) {\n      hdfs.allowSnapshot(snapshotDir);\n      hdfs.createSnapshot(snapshotDir, genSnapshotName(snapshotDir));\n    }\n\n    // delete file11\n    hdfs.delete(file11, true);\n    // modify file12\n    hdfs.setReplication(file12, REPLICATION);\n    // modify file13\n    hdfs.setReplication(file13, REPLICATION);\n    // delete link13\n    hdfs.delete(link13, false);\n    // create file14\n    DFSTestUtil.createFile(hdfs, file14, BLOCKSIZE, REPLICATION, SEED);\n    // create file15\n    DFSTestUtil.createFile(hdfs, file15, BLOCKSIZE, REPLICATION, SEED);\n\n    // create snapshot\n    for (Path snapshotDir : snapshotDirs) {\n      hdfs.createSnapshot(snapshotDir, genSnapshotName(snapshotDir));\n    }\n\n    // create file11 again\n    DFSTestUtil.createFile(hdfs, file11, BLOCKSIZE, REPLICATION, SEED);\n    // delete file12\n    hdfs.delete(file12, true);\n    // modify file13\n    hdfs.setReplication(file13, (short) (REPLICATION - 2));\n    // create link13 again\n    hdfs.createSymlink(file13, link13, false);\n    // delete file14\n    hdfs.delete(file14, true);\n    // modify file15\n    hdfs.setReplication(file15, (short) (REPLICATION - 1));\n\n    // create snapshot\n    for (Path snapshotDir : snapshotDirs) {\n      hdfs.createSnapshot(snapshotDir, genSnapshotName(snapshotDir));\n    }\n    // modify file10\n    hdfs.setReplication(file10, (short) (REPLICATION + 1));\n  }\n\n  /**\n   * Check the correctness of the diff reports.\n   */\n  private void verifyDiffReport(Path dir, String from, String to,\n      DiffReportEntry... entries) throws IOException {\n    DFSTestUtil.verifySnapshotDiffReport(hdfs, dir, from, to, entries);\n  }\n\n  /**\n   * Test the computation and representation of diff between snapshots.\n   */\n  @Test(timeout = 60000)\n  public void testDiffReport() throws Exception {\n    cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);\n\n    Path subsub1 = new Path(sub1, \"subsub1\");\n    Path subsubsub1 = new Path(subsub1, \"subsubsub1\");\n    hdfs.mkdirs(subsubsub1);\n    modifyAndCreateSnapshot(sub1, new Path[]{sub1, subsubsub1});\n    modifyAndCreateSnapshot(subsubsub1, new Path[]{sub1, subsubsub1});\n\n    final String invalidName = \"invalid\";\n    try {\n      hdfs.getSnapshotDiffReport(sub1, invalidName, invalidName);\n      fail(\"Expect exception when providing invalid snapshot name \" +\n          \"for diff report\");\n    } catch (IOException e) {\n      GenericTestUtils.assertExceptionContains(\n          \"Cannot find the snapshot of directory \" + sub1 + \" with name \"\n              + invalidName, e);\n    }\n\n    // diff between the same snapshot\n    SnapshotDiffReport report = hdfs.getSnapshotDiffReport(sub1, \"s0\", \"s0\");\n    LOG.info(report.toString());\n    assertEquals(0, report.getDiffList().size());\n\n    report = hdfs.getSnapshotDiffReport(sub1, \"\", \"\");\n    LOG.info(report.toString());\n    assertEquals(0, report.getDiffList().size());\n\n    try {\n      report = hdfs.getSnapshotDiffReport(subsubsub1, null, \"s2\");\n      fail(\"Expect exception when providing null fromSnapshot \");\n    } catch (IllegalArgumentException e) {\n      GenericTestUtils.assertExceptionContains(\"null fromSnapshot\", e);\n    }\n    report = hdfs.getSnapshotDiffReport(subsubsub1, \"s0\", \"s2\");\n    LOG.info(report.toString());\n    assertEquals(0, report.getDiffList().size());\n\n    // test path with scheme also works\n    report = hdfs.getSnapshotDiffReport(hdfs.makeQualified(subsubsub1),\n        \"s0\", \"s2\");\n    LOG.info(report.toString());\n    assertEquals(0, report.getDiffList().size());\n\n    verifyDiffReport(sub1, \"s0\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file15\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file12\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"link13\")));\n\n    verifyDiffReport(sub1, \"s0\", \"s5\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file15\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file12\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file15\")));\n\n    verifyDiffReport(sub1, \"s2\", \"s5\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file15\")));\n\n    verifyDiffReport(sub1, \"s3\", \"\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file15\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file12\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")));\n  }\n\n  @Test(timeout = 60000)\n  public void testSnapRootDescendantDiffReport() throws Exception {\n    Assume.assumeTrue(conf.getBoolean(\n        DFSConfigKeys.DFS_NAMENODE_SNAPSHOT_DIFF_ALLOW_SNAP_ROOT_DESCENDANT,\n        DFSConfigKeys.\n            DFS_NAMENODE_SNAPSHOT_DIFF_ALLOW_SNAP_ROOT_DESCENDANT_DEFAULT));\n    Path subSub = new Path(sub1, \"subsub1\");\n    Path subSubSub = new Path(subSub, \"subsubsub1\");\n    Path nonSnapDir = new Path(dir, \"non_snap\");\n    hdfs.mkdirs(subSubSub);\n    hdfs.mkdirs(nonSnapDir);\n\n    modifyAndCreateSnapshot(sub1, new Path[]{sub1});\n    modifyAndCreateSnapshot(subSub, new Path[]{sub1});\n    modifyAndCreateSnapshot(subSubSub, new Path[]{sub1});\n\n    try {\n      hdfs.getSnapshotDiffReport(subSub, \"s1\", \"s2\");\n      hdfs.getSnapshotDiffReport(subSubSub, \"s1\", \"s2\");\n    } catch (IOException e) {\n      fail(\"Unexpected exception when getting snapshot diff report \" +\n          subSub + \": \" + e);\n    }\n\n    try {\n      hdfs.getSnapshotDiffReport(nonSnapDir, \"s1\", \"s2\");\n      fail(\"Snapshot diff report on a non snapshot directory '\"\n          + nonSnapDir.getName() + \"'should fail!\");\n    } catch (SnapshotException e) {\n      GenericTestUtils.assertExceptionContains(\n          \"The path \" + nonSnapDir +\n              \" is neither snapshottable nor under a snapshot root!\", e);\n    }\n\n    final String invalidName = \"invalid\";\n    try {\n      hdfs.getSnapshotDiffReport(subSub, invalidName, invalidName);\n      fail(\"Expect exception when providing invalid snapshot name \" +\n          \"for diff report\");\n    } catch (IOException e) {\n      GenericTestUtils.assertExceptionContains(\n          \"Cannot find the snapshot of directory \" + sub1 + \" with name \"\n              + invalidName, e);\n    }\n\n    // diff between the same snapshot\n    SnapshotDiffReport report = hdfs.getSnapshotDiffReport(subSub, \"s0\", \"s0\");\n    assertEquals(0, report.getDiffList().size());\n\n    report = hdfs.getSnapshotDiffReport(subSub, \"\", \"\");\n    assertEquals(0, report.getDiffList().size());\n\n    report = hdfs.getSnapshotDiffReport(subSubSub, \"s0\", \"s2\");\n    assertEquals(0, report.getDiffList().size());\n\n    report = hdfs.getSnapshotDiffReport(\n        hdfs.makeQualified(subSubSub), \"s0\", \"s2\");\n    assertEquals(0, report.getDiffList().size());\n\n    verifyDescendantDiffReports(sub1, subSub, subSubSub);\n  }\n\n  private void verifyDescendantDiffReports(final Path snapDir,\n      final Path snapSubDir, final Path snapSubSubDir) throws\n      IOException {\n    verifyDiffReport(snapDir, \"s0\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file15\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file12\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"link13\")));\n    verifyDiffReport(snapSubDir, \"s0\", \"s2\", new DiffReportEntry[]{});\n    verifyDiffReport(snapSubSubDir, \"s0\", \"s2\", new DiffReportEntry[]{});\n\n    verifyDiffReport(snapDir, \"s0\", \"s8\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file15\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file12\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file15\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file15\")));\n\n    verifyDiffReport(snapSubDir, \"s0\", \"s8\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file15\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file15\")));\n\n    verifyDiffReport(snapSubSubDir, \"s0\", \"s8\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file15\")));\n\n    verifyDiffReport(snapDir, \"s2\", \"s5\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file15\")));\n\n    verifyDiffReport(snapSubDir, \"s2\", \"s5\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file15\")));\n    verifyDiffReport(snapSubSubDir, \"s2\", \"s5\",\n        new DiffReportEntry[]{});\n\n    verifyDiffReport(snapDir, \"s3\", \"\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file15\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/file12\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/file10\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/file11\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/link13\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/link13\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file15\")));\n\n    verifyDiffReport(snapSubDir, \"s3\", \"\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file15\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"file12\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsubsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsubsub1/file15\")));\n\n    verifyDiffReport(snapSubSubDir, \"s3\", \"\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file10\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"link13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file15\")));\n  }\n\n  @Test\n  public void testSnapRootDescendantDiffReportWithRename() throws Exception {\n    Assume.assumeTrue(conf.getBoolean(\n        DFSConfigKeys.DFS_NAMENODE_SNAPSHOT_DIFF_ALLOW_SNAP_ROOT_DESCENDANT,\n        DFSConfigKeys.\n            DFS_NAMENODE_SNAPSHOT_DIFF_ALLOW_SNAP_ROOT_DESCENDANT_DEFAULT));\n    Path subSub = new Path(sub1, \"subsub1\");\n    Path subSubSub = new Path(subSub, \"subsubsub1\");\n    Path nonSnapDir = new Path(dir, \"non_snap\");\n    hdfs.mkdirs(subSubSub);\n    hdfs.mkdirs(nonSnapDir);\n\n    hdfs.allowSnapshot(sub1);\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n    Path file20 = new Path(subSubSub, \"file20\");\n    DFSTestUtil.createFile(hdfs, file20, BLOCKSIZE, REPLICATION_1, SEED);\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n\n    // Case 1: Move a file away from a descendant dir, but within the snap root.\n    // mv <snaproot>/<subsub>/<subsubsub>/file20 <snaproot>/<subsub>/file20\n    hdfs.rename(file20, new Path(subSub, file20.getName()));\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n\n    // The snapshot diff for the snap root detects the change as file rename\n    // as the file move happened within the snap root.\n    verifyDiffReport(sub1, \"s1\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")),\n        new DiffReportEntry(DiffType.RENAME,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file20\"),\n            DFSUtil.string2Bytes(\"subsub1/file20\")));\n\n    // The snapshot diff for the descendant dir <subsub> still detects the\n    // change as file rename as the file move happened under the snap root\n    // descendant dir.\n    verifyDiffReport(subSub, \"s1\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsubsub1\")),\n        new DiffReportEntry(DiffType.RENAME,\n            DFSUtil.string2Bytes(\"subsubsub1/file20\"),\n            DFSUtil.string2Bytes(\"file20\")));\n\n    // The snapshot diff for the descendant dir <subsubsub> detects the\n    // change as file delete as the file got moved from its scope.\n    verifyDiffReport(subSubSub, \"s1\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"file20\")));\n\n    // Case 2: Move the file from the snap root descendant dir to any\n    // non snap root dir. mv <snaproot>/<subsub>/file20 <nonsnaproot>/file20.\n    hdfs.rename(new Path(subSub, file20.getName()),\n        new Path(dir, file20.getName()));\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n\n    // The snapshot diff for the snap root detects the change as file delete\n    // as the file got moved away from the snap root dir to some non snap\n    // root dir.\n    verifyDiffReport(sub1, \"s2\", \"s3\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/file20\")));\n\n    // The snapshot diff for the snap root descendant <subsub> detects the\n    // change as file delete as the file was previously under its scope and\n    // got moved away from its scope.\n    verifyDiffReport(subSub, \"s2\", \"s3\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"file20\")));\n\n    // The file was already not under the descendant dir <subsubsub> scope.\n    // So, the snapshot diff report for the descendant dir doesn't\n    // show the file rename at all.\n    verifyDiffReport(subSubSub, \"s2\", \"s3\",\n        new DiffReportEntry[]{});\n\n    // Case 3: Move the file from the non-snap root dir to snap root dir\n    // mv <nonsnaproot>/file20 <snaproot>/file20\n    hdfs.rename(new Path(dir, file20.getName()),\n        new Path(sub1, file20.getName()));\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n\n    // Snap root directory should show the file moved in as a new file.\n    verifyDiffReport(sub1, \"s3\", \"s4\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file20\")));\n\n    // Snap descendant directories don't have visibility to the moved in file.\n    verifyDiffReport(subSub, \"s3\", \"s4\",\n        new DiffReportEntry[]{});\n    verifyDiffReport(subSubSub, \"s3\", \"s4\",\n        new DiffReportEntry[]{});\n\n    hdfs.rename(new Path(sub1, file20.getName()),\n        new Path(subSub, file20.getName()));\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n\n    // Snap root directory now shows the rename as both source and\n    // destination paths are under the snap root.\n    verifyDiffReport(sub1, \"s4\", \"s5\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.RENAME,\n            DFSUtil.string2Bytes(\"file20\"),\n            DFSUtil.string2Bytes(\"subsub1/file20\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")));\n\n    // For the descendant directory under the snap root, the file\n    // moved in shows up as a new file created.\n    verifyDiffReport(subSub, \"s4\", \"s5\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"file20\")));\n\n    verifyDiffReport(subSubSub, \"s4\", \"s5\",\n        new DiffReportEntry[]{});\n\n    // Case 4: Snapshot diff for the newly created descendant directory.\n    Path subSubSub2 = new Path(subSub, \"subsubsub2\");\n    hdfs.mkdirs(subSubSub2);\n    Path file30 = new Path(subSubSub2, \"file30\");\n    DFSTestUtil.createFile(hdfs, file30, BLOCKSIZE, REPLICATION_1, SEED);\n    hdfs.createFile(file30);\n    hdfs.createSnapshot(sub1, genSnapshotName(sub1));\n\n    verifyDiffReport(sub1, \"s5\", \"s6\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub2\")));\n\n    verifyDiffReport(subSubSub2, \"s5\", \"s6\",\n        new DiffReportEntry[]{});\n\n    verifyDiffReport(subSubSub2, \"s1\", \"s2\",\n        new DiffReportEntry[]{});\n  }\n\n  @Test\n  public void testSnapshotDiffInfo() throws Exception {\n    Path snapshotRootDirPath = dir;\n    Path snapshotDirDescendantPath = new Path(snapshotRootDirPath, \"desc\");\n    Path snapshotDirNonDescendantPath = new Path(\"/dummy/non/snap/desc\");\n    hdfs.mkdirs(snapshotDirDescendantPath);\n    hdfs.mkdirs(snapshotDirNonDescendantPath);\n\n    hdfs.allowSnapshot(snapshotRootDirPath);\n    hdfs.createSnapshot(snapshotRootDirPath, \"s0\");\n    hdfs.createSnapshot(snapshotRootDirPath, \"s1\");\n\n    INodeDirectory snapshotRootDir = cluster.getNameNode()\n        .getNamesystem().getFSDirectory().getINode(\n            snapshotRootDirPath.toUri().getPath())\n        .asDirectory();\n    INodeDirectory snapshotRootDescendantDir = cluster.getNameNode()\n        .getNamesystem().getFSDirectory().getINode(\n            snapshotDirDescendantPath.toUri().getPath())\n        .asDirectory();\n    INodeDirectory snapshotRootNonDescendantDir = cluster.getNameNode()\n        .getNamesystem().getFSDirectory().getINode(\n            snapshotDirNonDescendantPath.toUri().getPath())\n        .asDirectory();\n    try {\n      SnapshotDiffInfo sdi = new SnapshotDiffInfo(\n          snapshotRootDir,\n          snapshotRootDescendantDir,\n          new Snapshot(0, \"s0\", snapshotRootDescendantDir),\n          new Snapshot(0, \"s1\", snapshotRootDescendantDir));\n      LOG.info(\"SnapshotDiffInfo: \" + sdi.getFrom() + \" - \" + sdi.getTo());\n    } catch (IllegalArgumentException iae){\n      fail(\"Unexpected exception when constructing SnapshotDiffInfo: \" + iae);\n    }\n\n    try {\n      SnapshotDiffInfo sdi = new SnapshotDiffInfo(\n          snapshotRootDir,\n          snapshotRootNonDescendantDir,\n          new Snapshot(0, \"s0\", snapshotRootNonDescendantDir),\n          new Snapshot(0, \"s1\", snapshotRootNonDescendantDir));\n      LOG.info(\"SnapshotDiffInfo: \" + sdi.getFrom() + \" - \" + sdi.getTo());\n      fail(\"SnapshotDiffInfo construction should fail for non snapshot root \" +\n          \"or non snapshot root descendant directories!\");\n    } catch (IllegalArgumentException iae) {\n      // expected exception\n    }\n  }\n\n  /**\n   * Make changes under a sub-directory, then delete the sub-directory. Make\n   * sure the diff report computation correctly retrieve the diff from the\n   * deleted sub-directory.\n   */\n  @Test (timeout=60000)\n  public void testDiffReport2() throws Exception {\n    Path subsub1 = new Path(sub1, \"subsub1\");\n    Path subsubsub1 = new Path(subsub1, \"subsubsub1\");\n    hdfs.mkdirs(subsubsub1);\n    modifyAndCreateSnapshot(subsubsub1, new Path[]{sub1});\n    \n    // delete subsub1\n    hdfs.delete(subsub1, true);\n    // check diff report between s0 and s2\n    verifyDiffReport(sub1, \"s0\", \"s2\", \n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1\")), \n        new DiffReportEntry(DiffType.CREATE, \n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file15\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file12\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file11\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/file13\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"subsub1/subsubsub1/link13\")));\n    // check diff report between s0 and the current status\n    verifyDiffReport(sub1, \"s0\", \"\", \n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"subsub1\")));\n  }\n\n  @Test\n  public void testDiffReportWithQuota() throws Exception {\n    final Path testdir = new Path(sub1, \"testdir1\");\n    hdfs.mkdirs(testdir);\n    hdfs.allowSnapshot(testdir);\n    // Set quota BEFORE creating the snapshot\n    hdfs.setQuota(testdir, 10, 10);\n    hdfs.createSnapshot(testdir, \"s0\");\n    final SnapshotDiffReport report =\n        hdfs.getSnapshotDiffReport(testdir, \"s0\", \"\");\n    // The diff should be null. Snapshot dir inode should keep the quota.\n    Assert.assertEquals(0, report.getDiffList().size());\n    // Cleanup\n    hdfs.deleteSnapshot(testdir, \"s0\");\n    hdfs.disallowSnapshot(testdir);\n    hdfs.delete(testdir, true);\n  }\n\n  /**\n   * Rename a directory to its prior descendant, and verify the diff report.\n   */\n  @Test\n  public void testDiffReportWithRename() throws Exception {\n    final Path root = new Path(\"/\");\n    final Path sdir1 = new Path(root, \"dir1\");\n    final Path sdir2 = new Path(root, \"dir2\");\n    final Path foo = new Path(sdir1, \"foo\");\n    final Path bar = new Path(foo, \"bar\");\n    hdfs.mkdirs(bar);\n    hdfs.mkdirs(sdir2);\n\n    // create snapshot on root\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n\n    // /dir1/foo/bar -> /dir2/bar\n    final Path bar2 = new Path(sdir2, \"bar\");\n    hdfs.rename(bar, bar2);\n\n    // /dir1/foo -> /dir2/bar/foo\n    final Path foo2 = new Path(bar2, \"foo\");\n    hdfs.rename(foo, foo2);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s2\");\n    // let's delete /dir2 to make things more complicated\n    hdfs.delete(sdir2, true);\n\n    verifyDiffReport(root, \"s1\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/foo\"),\n            DFSUtil.string2Bytes(\"dir2/bar/foo\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir2\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(\"dir1/foo/bar\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1/foo\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil\n            .string2Bytes(\"dir1/foo/bar\"), DFSUtil.string2Bytes(\"dir2/bar\")));\n  }\n\n  /**\n   * Rename a file/dir outside of the snapshottable dir should be reported as\n   * deleted. Rename a file/dir from outside should be reported as created.\n   */\n  @Test\n  public void testDiffReportWithRenameOutside() throws Exception {\n    final Path root = new Path(\"/\");\n    final Path dir1 = new Path(root, \"dir1\");\n    final Path dir2 = new Path(root, \"dir2\");\n    final Path foo = new Path(dir1, \"foo\");\n    final Path fileInFoo = new Path(foo, \"file\");\n    final Path bar = new Path(dir2, \"bar\");\n    final Path fileInBar = new Path(bar, \"file\");\n    DFSTestUtil.createFile(hdfs, fileInFoo, BLOCKSIZE, REPLICATION, SEED);\n    DFSTestUtil.createFile(hdfs, fileInBar, BLOCKSIZE, REPLICATION, SEED);\n\n    // create snapshot on /dir1\n    SnapshotTestHelper.createSnapshot(hdfs, dir1, \"s0\");\n\n    // move bar into dir1\n    final Path newBar = new Path(dir1, \"newBar\");\n    hdfs.rename(bar, newBar);\n    // move foo out of dir1 into dir2\n    final Path newFoo = new Path(dir2, \"new\");\n    hdfs.rename(foo, newFoo);\n\n    SnapshotTestHelper.createSnapshot(hdfs, dir1, \"s1\");\n    verifyDiffReport(dir1, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(newBar\n            .getName())),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(foo.getName())));\n  }\n\n  /**\n   * Renaming a file/dir then delete the ancestor dir of the rename target\n   * should be reported as deleted.\n   */\n  @Test\n  public void testDiffReportWithRenameAndDelete() throws Exception {\n    final Path root = new Path(\"/\");\n    final Path dir1 = new Path(root, \"dir1\");\n    final Path dir2 = new Path(root, \"dir2\");\n    final Path foo = new Path(dir1, \"foo\");\n    final Path fileInFoo = new Path(foo, \"file\");\n    final Path bar = new Path(dir2, \"bar\");\n    final Path fileInBar = new Path(bar, \"file\");\n    DFSTestUtil.createFile(hdfs, fileInFoo, BLOCKSIZE, REPLICATION, SEED);\n    DFSTestUtil.createFile(hdfs, fileInBar, BLOCKSIZE, REPLICATION, SEED);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    hdfs.rename(fileInFoo, fileInBar, Rename.OVERWRITE);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    verifyDiffReport(root, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1/foo\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir2/bar\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil\n            .string2Bytes(\"dir2/bar/file\")),\n        new DiffReportEntry(DiffType.RENAME,\n            DFSUtil.string2Bytes(\"dir1/foo/file\"),\n            DFSUtil.string2Bytes(\"dir2/bar/file\")));\n\n    // delete bar\n    hdfs.delete(bar, true);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s2\");\n    verifyDiffReport(root, \"s0\", \"s2\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1/foo\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir2\")),\n        new DiffReportEntry(DiffType.DELETE, DFSUtil.string2Bytes(\"dir2/bar\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir1/foo/file\")));\n  }\n\n  @Test\n  public void testDiffReportWithRenameToNewDir() throws Exception {\n    final Path root = new Path(\"/\");\n    final Path foo = new Path(root, \"foo\");\n    final Path fileInFoo = new Path(foo, \"file\");\n    DFSTestUtil.createFile(hdfs, fileInFoo, BLOCKSIZE, REPLICATION, SEED);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    final Path bar = new Path(root, \"bar\");\n    hdfs.mkdirs(bar);\n    final Path fileInBar = new Path(bar, \"file\");\n    hdfs.rename(fileInFoo, fileInBar);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n\n    verifyDiffReport(root, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"foo\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"bar\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"foo/file\"),\n            DFSUtil.string2Bytes(\"bar/file\")));\n  }\n\n  /**\n   * Rename a file and then append some data to it\n   */\n  @Test\n  public void testDiffReportWithRenameAndAppend() throws Exception {\n    final Path root = new Path(\"/\");\n    final Path foo = new Path(root, \"foo\");\n    DFSTestUtil.createFile(hdfs, foo, BLOCKSIZE, REPLICATION, SEED);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    final Path bar = new Path(root, \"bar\");\n    hdfs.rename(foo, bar);\n    DFSTestUtil.appendFile(hdfs, bar, 10); // append 10 bytes\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n\n    // we always put modification on the file before rename\n    verifyDiffReport(root, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"foo\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"foo\"),\n            DFSUtil.string2Bytes(\"bar\")));\n  }\n\n  /**\n   * Nested renamed dir/file and the withNameList in the WithCount node of the\n   * parental directory is empty due to snapshot deletion. See HDFS-6996 for\n   * details.\n   */\n  @Test\n  public void testDiffReportWithRenameAndSnapshotDeletion() throws Exception {\n    final Path root = new Path(\"/\");\n    final Path foo = new Path(root, \"foo\");\n    final Path bar = new Path(foo, \"bar\");\n    DFSTestUtil.createFile(hdfs, bar, BLOCKSIZE, REPLICATION, SEED);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    // rename /foo to /foo2\n    final Path foo2 = new Path(root, \"foo2\");\n    hdfs.rename(foo, foo2);\n    // now /foo/bar becomes /foo2/bar\n    final Path bar2 = new Path(foo2, \"bar\");\n\n    // delete snapshot s0 so that the withNameList inside of the WithCount node\n    // of foo becomes empty\n    hdfs.deleteSnapshot(root, \"s0\");\n\n    // create snapshot s1 and rename bar again\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    final Path bar3 = new Path(foo2, \"bar-new\");\n    hdfs.rename(bar2, bar3);\n\n    // we always put modification on the file before rename\n    verifyDiffReport(root, \"s1\", \"\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"foo2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"foo2/bar\"),\n            DFSUtil.string2Bytes(\"foo2/bar-new\")));\n  }\n\n  private void createFile(final Path filePath) throws IOException {\n    DFSTestUtil.createFile(hdfs, filePath, (int) BUFFERLEN,\n        FILELEN, BLOCKSIZE, REPLICATION, SEED);\n  }\n\n  private int writeToStream(final FSDataOutputStream outputStream,\n      byte[] buf) throws IOException {\n    outputStream.write(buf);\n    ((HdfsDataOutputStream)outputStream).hsync(\n        EnumSet.of(SyncFlag.UPDATE_LENGTH));\n    return buf.length;\n  }\n\n  private void restartNameNode() throws Exception {\n    cluster.triggerBlockReports();\n    NameNode nameNode = cluster.getNameNode();\n    NameNodeAdapter.enterSafeMode(nameNode, false);\n    NameNodeAdapter.saveNamespace(nameNode);\n    NameNodeAdapter.leaveSafeMode(nameNode);\n    cluster.restartNameNode(true);\n  }\n\n  /**\n   * Test Snapshot diff report for snapshots with open files captures in them.\n   * Also verify if the diff report remains the same across NameNode restarts.\n   */\n  @Test (timeout = 120000)\n  public void testDiffReportWithOpenFiles() throws Exception {\n    // Construct the directory tree\n    final Path level0A = new Path(\"/level_0_A\");\n    final Path flumeSnapRootDir = level0A;\n    final String flumeFileName = \"flume.log\";\n    final String flumeSnap1Name = \"flume_snap_1\";\n    final String flumeSnap2Name = \"flume_snap_2\";\n\n    // Create files and open a stream\n    final Path flumeFile = new Path(level0A, flumeFileName);\n    createFile(flumeFile);\n    FSDataOutputStream flumeOutputStream = hdfs.append(flumeFile);\n\n    // Create Snapshot S1\n    final Path flumeS1Dir = SnapshotTestHelper.createSnapshot(\n        hdfs, flumeSnapRootDir, flumeSnap1Name);\n    final Path flumeS1Path = new Path(flumeS1Dir, flumeFileName);\n    final long flumeFileLengthAfterS1 = hdfs.getFileStatus(flumeFile).getLen();\n\n    // Verify if Snap S1 file length is same as the the live one\n    Assert.assertEquals(flumeFileLengthAfterS1,\n        hdfs.getFileStatus(flumeS1Path).getLen());\n\n    verifyDiffReport(level0A, flumeSnap1Name, \"\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")));\n\n    long flumeFileWrittenDataLength = flumeFileLengthAfterS1;\n    int newWriteLength = (int) (BLOCKSIZE * 1.5);\n    byte[] buf = new byte[newWriteLength];\n    Random random = new Random();\n    random.nextBytes(buf);\n\n    // Write more data to flume file\n    flumeFileWrittenDataLength += writeToStream(flumeOutputStream, buf);\n\n    // Create Snapshot S2\n    final Path flumeS2Dir = SnapshotTestHelper.createSnapshot(\n        hdfs, flumeSnapRootDir, flumeSnap2Name);\n    final Path flumeS2Path = new Path(flumeS2Dir, flumeFileName);\n\n    // Verify live files length is same as all data written till now\n    final long flumeFileLengthAfterS2 = hdfs.getFileStatus(flumeFile).getLen();\n    Assert.assertEquals(flumeFileWrittenDataLength, flumeFileLengthAfterS2);\n\n    // Verify if Snap S2 file length is same as the live one\n    Assert.assertEquals(flumeFileLengthAfterS2,\n        hdfs.getFileStatus(flumeS2Path).getLen());\n\n    verifyDiffReport(level0A, flumeSnap1Name, \"\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(flumeFileName)));\n\n    verifyDiffReport(level0A, flumeSnap2Name, \"\");\n\n    verifyDiffReport(level0A, flumeSnap1Name, flumeSnap2Name,\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(flumeFileName)));\n\n    // Write more data to flume file\n    flumeFileWrittenDataLength += writeToStream(flumeOutputStream, buf);\n\n    // Verify old flume snapshots have point-in-time / frozen file lengths\n    // even after the live file have moved forward.\n    Assert.assertEquals(flumeFileLengthAfterS1,\n        hdfs.getFileStatus(flumeS1Path).getLen());\n    Assert.assertEquals(flumeFileLengthAfterS2,\n        hdfs.getFileStatus(flumeS2Path).getLen());\n\n    flumeOutputStream.close();\n\n    // Verify if Snap S2 file length is same as the live one\n    Assert.assertEquals(flumeFileWrittenDataLength,\n        hdfs.getFileStatus(flumeFile).getLen());\n\n    // Verify old flume snapshots have point-in-time / frozen file lengths\n    // even after the live file have moved forward.\n    Assert.assertEquals(flumeFileLengthAfterS1,\n        hdfs.getFileStatus(flumeS1Path).getLen());\n    Assert.assertEquals(flumeFileLengthAfterS2,\n        hdfs.getFileStatus(flumeS2Path).getLen());\n\n    verifyDiffReport(level0A, flumeSnap1Name, \"\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(flumeFileName)));\n\n    verifyDiffReport(level0A, flumeSnap2Name, \"\",\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(flumeFileName)));\n\n    verifyDiffReport(level0A, flumeSnap1Name, flumeSnap2Name,\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(flumeFileName)));\n\n    restartNameNode();\n\n    verifyDiffReport(level0A, flumeSnap1Name, flumeSnap2Name,\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY,\n            DFSUtil.string2Bytes(flumeFileName)));\n\n  }\n\n  private long getAccessTime(Path path) throws IOException {\n    return hdfs.getFileStatus(path).getAccessTime();\n  }\n\n  private String getAccessTimeStr(Path path) throws IOException {\n    SimpleDateFormat timeFmt = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    return timeFmt.format(new Date(getAccessTime(path)));\n  }\n\n  private Path getSSpath(Path path, Path ssRoot, String ssName) {\n    return new Path(ssRoot, \".snapshot/\" + ssName + \"/\" +\n        path.toString().substring(ssRoot.toString().length()));\n  }\n\n  private void printAtime(Path path, Path ssRoot, String ssName)\n      throws IOException {\n    Path ssPath = getSSpath(path, ssRoot, ssName);\n    LOG.info(\"Access time \"\n        + path + \": \" + getAccessTimeStr(path)\n        + \" \" + ssPath + \": \" + getAccessTimeStr(ssPath));\n  }\n\n  private void assertAtimeEquals(Path path, Path ssRoot,\n      String ssName1, String ssName2)\n      throws IOException {\n    Path ssPath1 = getSSpath(path, ssRoot, ssName1);\n    Path ssPath2 = getSSpath(path, ssRoot, ssName2);\n    assertEquals(getAccessTime(ssPath1), getAccessTime(ssPath2));\n  }\n\n  private void assertAtimeNotEquals(Path path, Path ssRoot,\n      String ssName1, String ssName2)\n      throws IOException {\n    Path ssPath1 = getSSpath(path, ssRoot, ssName1);\n    Path ssPath2 = getSSpath(path, ssRoot, ssName2);\n    assertNotEquals(getAccessTime(ssPath1), getAccessTime(ssPath2));\n  }\n\n  /**\n   * Check to see access time is not captured in snapshot when applicable.\n   * When DFS_NAMENODE_SNAPSHOT_SKIP_CAPTURE_ACCESSTIME_ONLY_CHANGE\n   * is set to true, and if a file's access time changed between two\n   * snapshots but has no other modification, then the access time is not\n   * captured in snapshot.\n   */\n  @Test\n  public void testDontCaptureAccessTimeOnlyChangeReport() throws Exception {\n    final Path froot = new Path(\"/\");\n    final Path root = new Path(froot, \"/testSdiffCalc\");\n\n    // items created pre enabling snapshot\n    final Path filePreSS = new Path(root, \"fParent/filePreSS\");\n    final Path dirPreSS = new Path(root, \"dirPreSS\");\n    final Path dirPreSSChild = new Path(dirPreSS, \"dirPreSSChild\");\n\n    // items created after enabling snapshot\n    final Path filePostSS = new Path(root, \"fParent/filePostSS\");\n    final Path dirPostSS = new Path(root, \"dirPostSS\");\n    final Path dirPostSSChild = new Path(dirPostSS, \"dirPostSSChild\");\n\n    DFSTestUtil.createFile(hdfs, filePreSS, BLOCKSIZE, REPLICATION, SEED);\n    DFSTestUtil.createFile(hdfs, dirPreSSChild, BLOCKSIZE, REPLICATION, SEED);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    printAtime(filePreSS, root, \"s0\");\n    printAtime(dirPreSS, root, \"s0\");\n\n    // items created after creating the first snapshot\n    DFSTestUtil.createFile(hdfs, filePostSS, BLOCKSIZE, REPLICATION, SEED);\n    DFSTestUtil.createFile(hdfs, dirPostSSChild, BLOCKSIZE, REPLICATION, SEED);\n\n    Thread.sleep(3000);\n    long now = Time.now();\n    hdfs.setTimes(filePreSS, -1, now);\n    hdfs.setTimes(filePostSS, -1, now);\n    hdfs.setTimes(dirPreSS, -1, now);\n    hdfs.setTimes(dirPostSS, -1, now);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    printAtime(filePreSS, root, \"s1\");\n    printAtime(dirPreSS, root, \"s1\");\n    printAtime(filePostSS, root, \"s1\");\n    printAtime(dirPostSS, root, \"s1\");\n\n    Thread.sleep(3000);\n    now = Time.now();\n    hdfs.setTimes(filePreSS, -1, now);\n    hdfs.setTimes(filePostSS, -1, now);\n    hdfs.setTimes(dirPreSS, -1, now);\n    hdfs.setTimes(dirPostSS, -1, now);\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s2\");\n    printAtime(filePreSS, root, \"s2\");\n    printAtime(dirPreSS, root, \"s2\");\n    printAtime(filePostSS, root, \"s2\");\n    printAtime(dirPostSS, root, \"s2\");\n\n    Thread.sleep(3000);\n    now = Time.now();\n    // modify filePostSS, and change access time\n    hdfs.setReplication(filePostSS, (short) (REPLICATION - 1));\n    hdfs.setTimes(filePostSS, -1, now);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s3\");\n\n    LOG.info(\"\\nsnapshotDiff s0 -> s1:\");\n    LOG.info(hdfs.getSnapshotDiffReport(root, \"s0\", \"s1\").toString());\n    LOG.info(\"\\nsnapshotDiff s1 -> s2:\");\n    LOG.info(hdfs.getSnapshotDiffReport(root, \"s1\", \"s2\").toString());\n\n    assertAtimeEquals(filePreSS, root, \"s0\", \"s1\");\n    assertAtimeEquals(dirPreSS, root, \"s0\", \"s1\");\n\n    assertAtimeEquals(filePreSS, root, \"s1\", \"s2\");\n    assertAtimeEquals(dirPreSS, root, \"s1\", \"s2\");\n\n    assertAtimeEquals(filePostSS, root, \"s1\", \"s2\");\n    assertAtimeEquals(dirPostSS, root, \"s1\", \"s2\");\n\n    // access time should be captured in snapshot due to\n    // other modification\n    assertAtimeNotEquals(filePostSS, root, \"s2\", \"s3\");\n\n    // restart NN, and see the access time relationship\n    // still stands (no change caused by edit logs\n    // loading)\n    cluster.restartNameNodes();\n    cluster.waitActive();\n    assertAtimeEquals(filePreSS, root, \"s0\", \"s1\");\n    assertAtimeEquals(dirPreSS, root, \"s0\", \"s1\");\n\n    assertAtimeEquals(filePreSS, root, \"s1\", \"s2\");\n    assertAtimeEquals(dirPreSS, root, \"s1\", \"s2\");\n\n    assertAtimeEquals(filePostSS, root, \"s1\", \"s2\");\n    assertAtimeEquals(dirPostSS, root, \"s1\", \"s2\");\n\n    assertAtimeNotEquals(filePostSS, root, \"s2\", \"s3\");\n  }\n\n  /**\n   * Tests to verfy the diff report with maximum SnapsdiffReportEntries limit\n   * over an rpc being set to 3.\n   * @throws Exception\n   */\n  @Test\n  public void testDiffReportWithRpcLimit() throws Exception {\n    final Path root = new Path(\"/\");\n    hdfs.mkdirs(root);\n    for (int i = 1; i < 4; i++) {\n      final Path path = new Path(root, \"dir\" + i);\n      hdfs.mkdirs(path);\n    }\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    for (int i = 1; i < 4; i++) {\n      final Path path = new Path(root, \"dir\" + i);\n      for (int j = 1; j < 4; j++) {\n        final Path file = new Path(path, \"file\" + j);\n        DFSTestUtil.createFile(hdfs, file, BLOCKSIZE, REPLICATION, SEED);\n      }\n    }\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    verifyDiffReport(root, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file2\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file3\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir2\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir2/file1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir2/file2\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir2/file3\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir3\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir3/file2\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir3/file3\")));\n  }\n\n  @Test\n  public void testDiffReportWithRpcLimit2() throws Exception {\n    final Path root = new Path(\"/\");\n    hdfs.mkdirs(root);\n    for (int i = 1; i <=3; i++) {\n      final Path path = new Path(root, \"dir\" + i);\n      hdfs.mkdirs(path);\n    }\n    for (int i = 1; i <= 3; i++) {\n      final Path path = new Path(root, \"dir\" + i);\n      for (int j = 1; j < 4; j++) {\n        final Path file = new Path(path, \"file\" + j);\n        DFSTestUtil.createFile(hdfs, file, BLOCKSIZE, REPLICATION, SEED);\n      }\n    }\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    Path targetDir = new Path(root, \"dir4\");\n    //create directory dir4\n    hdfs.mkdirs(targetDir);\n    //moves files from dir1 to dir4\n    Path path = new Path(root, \"dir1\");\n    for (int j = 1; j < 4; j++) {\n      final Path srcPath = new Path(path, \"file\" + j);\n      final Path targetPath = new Path(targetDir, \"file\" + j);\n      hdfs.rename(srcPath, targetPath);\n    }\n    targetDir = new Path(root, \"dir3\");\n    //overwrite existing files in dir3 from files in dir1\n    path = new Path(root, \"dir2\");\n    for (int j = 1; j < 4; j++) {\n      final Path srcPath = new Path(path, \"file\" + j);\n      final Path targetPath = new Path(targetDir, \"file\" + j);\n      hdfs.rename(srcPath, targetPath, Rename.OVERWRITE);\n    }\n    final Path pathToRename = new Path(root, \"dir2\");\n    //move dir2 inside dir3\n    hdfs.rename(pathToRename, targetDir);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    verifyDiffReport(root, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir4\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2\"),\n            DFSUtil.string2Bytes(\"dir3/dir2\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/file1\"),\n            DFSUtil.string2Bytes(\"dir4/file1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/file2\"),\n            DFSUtil.string2Bytes(\"dir4/file2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/file3\"),\n            DFSUtil.string2Bytes(\"dir4/file3\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2/file1\"),\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2/file2\"),\n            DFSUtil.string2Bytes(\"dir3/file2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2/file3\"),\n            DFSUtil.string2Bytes(\"dir3/file3\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir3\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir3/file3\")));\n  }\n\n  /**\n   * Tests to verify the diff report with maximum SnapsdiffReportEntries limit\n   * over an rpc being set to 3.\n   * @throws Exception\n   */\n  @Test\n  public void testDiffReportWithRpcLimit3() throws Exception {\n    final Path root = new Path(\"/\");\n    hdfs.mkdirs(root);\n    Path path = new Path(root, \"dir1\");\n    hdfs.mkdirs(path);\n    for (int j = 1; j <= 4; j++) {\n      final Path file = new Path(path, \"file\" + j);\n      DFSTestUtil.createFile(hdfs, file, BLOCKSIZE, REPLICATION, SEED);\n    }\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    path = new Path(root, \"dir1\");\n    for (int j = 1; j <= 4; j++) {\n      final Path file = new Path(path, \"file\" + j);\n      hdfs.delete(file, false);\n    }\n    for (int j = 5; j <= 10; j++) {\n      final Path file = new Path(path, \"file\" + j);\n      DFSTestUtil.createFile(hdfs, file, BLOCKSIZE, REPLICATION, SEED);\n    }\n\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    verifyDiffReport(root, \"s0\", \"s1\",\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file5\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file6\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file7\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file8\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file9\")),\n        new DiffReportEntry(DiffType.CREATE,\n            DFSUtil.string2Bytes(\"dir1/file10\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir1/file1\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir1/file2\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir1/file3\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir1/file4\")));\n  }\n\n  private void verifyDiffReportForGivenReport(Path dirPath, String from,\n      String to, SnapshotDiffReport report, DiffReportEntry... entries)\n      throws IOException {\n    // reverse the order of from and to\n    SnapshotDiffReport inverseReport =\n        hdfs.getSnapshotDiffReport(dirPath, to, from);\n    LOG.info(report.toString());\n    LOG.info(inverseReport.toString() + \"\\n\");\n\n    assertEquals(entries.length, report.getDiffList().size());\n    assertEquals(entries.length, inverseReport.getDiffList().size());\n\n    for (DiffReportEntry entry : entries) {\n      if (entry.getType() == DiffType.MODIFY) {\n        assertTrue(report.getDiffList().contains(entry));\n        assertTrue(inverseReport.getDiffList().contains(entry));\n      } else if (entry.getType() == DiffType.DELETE) {\n        assertTrue(report.getDiffList().contains(entry));\n        assertTrue(inverseReport.getDiffList().contains(\n            new DiffReportEntry(DiffType.CREATE, entry.getSourcePath())));\n      } else if (entry.getType() == DiffType.CREATE) {\n        assertTrue(report.getDiffList().contains(entry));\n        assertTrue(inverseReport.getDiffList().contains(\n            new DiffReportEntry(DiffType.DELETE, entry.getSourcePath())));\n      }\n    }\n  }\n\n  @Test\n  public void testSnapshotDiffReportRemoteIterator() throws Exception {\n    final Path root = new Path(\"/\");\n    hdfs.mkdirs(root);\n    for (int i = 1; i <= 3; i++) {\n      final Path path = new Path(root, \"dir\" + i);\n      hdfs.mkdirs(path);\n    }\n    for (int i = 1; i <= 3; i++) {\n      final Path path = new Path(root, \"dir\" + i);\n      for (int j = 1; j < 4; j++) {\n        final Path file = new Path(path, \"file\" + j);\n        DFSTestUtil.createFile(hdfs, file, BLOCKSIZE, REPLICATION, SEED);\n      }\n    }\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    Path targetDir = new Path(root, \"dir4\");\n    //create directory dir4\n    hdfs.mkdirs(targetDir);\n    //moves files from dir1 to dir4\n    Path path = new Path(root, \"dir1\");\n    for (int j = 1; j < 4; j++) {\n      final Path srcPath = new Path(path, \"file\" + j);\n      final Path targetPath = new Path(targetDir, \"file\" + j);\n      hdfs.rename(srcPath, targetPath);\n    }\n    targetDir = new Path(root, \"dir3\");\n    //overwrite existing files in dir3 from files in dir1\n    path = new Path(root, \"dir2\");\n    for (int j = 1; j < 4; j++) {\n      final Path srcPath = new Path(path, \"file\" + j);\n      final Path targetPath = new Path(targetDir, \"file\" + j);\n      hdfs.rename(srcPath, targetPath, Rename.OVERWRITE);\n    }\n    final Path pathToRename = new Path(root, \"dir2\");\n    //move dir2 inside dir3\n    hdfs.rename(pathToRename, targetDir);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s1\");\n    RemoteIterator<SnapshotDiffReportListing> iterator =\n        hdfs.snapshotDiffReportListingRemoteIterator(root, \"s0\", \"s1\");\n    SnapshotDiffReportGenerator snapshotDiffReport;\n    List<SnapshotDiffReportListing.DiffReportListingEntry> modifiedList =\n        new TreeList();\n    List<SnapshotDiffReportListing.DiffReportListingEntry> createdList =\n        new ChunkedArrayList<>();\n    List<SnapshotDiffReportListing.DiffReportListingEntry> deletedList =\n        new ChunkedArrayList<>();\n    SnapshotDiffReportListing report = null;\n    List<SnapshotDiffReportListing> reportList = new ArrayList<>();\n    while (iterator.hasNext()) {\n      report = iterator.next();\n      reportList.add(report);\n      modifiedList.addAll(report.getModifyList());\n      createdList.addAll(report.getCreateList());\n      deletedList.addAll(report.getDeleteList());\n    }\n    try {\n      iterator.next();\n    } catch (Exception e) {\n      Assert.assertTrue(\n          e.getMessage().contains(\"No more entry in SnapshotDiffReport for /\"));\n    }\n    Assert.assertNotEquals(0, reportList.size());\n    // generate the snapshotDiffReport and Verify\n    snapshotDiffReport = new SnapshotDiffReportGenerator(\"/\", \"s0\", \"s1\",\n        report.getIsFromEarlier(), modifiedList, createdList, deletedList);\n    verifyDiffReportForGivenReport(root, \"s0\", \"s1\",\n        snapshotDiffReport.generateReport(),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"\")),\n        new DiffReportEntry(DiffType.CREATE, DFSUtil.string2Bytes(\"dir4\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2\"),\n            DFSUtil.string2Bytes(\"dir3/dir2\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/file1\"),\n            DFSUtil.string2Bytes(\"dir4/file1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/file2\"),\n            DFSUtil.string2Bytes(\"dir4/file2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir1/file3\"),\n            DFSUtil.string2Bytes(\"dir4/file3\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2/file1\"),\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2/file2\"),\n            DFSUtil.string2Bytes(\"dir3/file2\")),\n        new DiffReportEntry(DiffType.RENAME, DFSUtil.string2Bytes(\"dir2/file3\"),\n            DFSUtil.string2Bytes(\"dir3/file3\")),\n        new DiffReportEntry(DiffType.MODIFY, DFSUtil.string2Bytes(\"dir3\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir3/file1\")),\n        new DiffReportEntry(DiffType.DELETE,\n            DFSUtil.string2Bytes(\"dir3/file3\")));\n  }\n\n  @Test\n  public void testSnapshotDiffReportRemoteIterator2() throws Exception {\n    final Path root = new Path(\"/\");\n    hdfs.mkdirs(root);\n    SnapshotTestHelper.createSnapshot(hdfs, root, \"s0\");\n    try {\n      hdfs.snapshotDiffReportListingRemoteIterator(root, \"s0\", \"\");\n    } catch (Exception e) {\n      Assert.assertTrue(e.getMessage().contains(\"Remote Iterator is\"\n          + \"supported for snapshotDiffReport between two snapshots\"));\n    }\n  }\n}\n"
    },
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\AWD\\apache\\hadoop\\commit_1200\\2245\\before\\hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FSDataOutputStream.java",
      "chunk_type": "superType",
      "ast_subtree": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.fs;\n\nimport java.io.DataOutputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.fs.impl.StoreImplementationUtils;\nimport org.apache.hadoop.fs.statistics.IOStatistics;\nimport org.apache.hadoop.fs.statistics.IOStatisticsSource;\nimport org.apache.hadoop.fs.statistics.IOStatisticsSupport;\n\n/** Utility that wraps a {@link OutputStream} in a {@link DataOutputStream}.\n */\n@InterfaceAudience.Public\n@InterfaceStability.Stable\npublic class FSDataOutputStream extends DataOutputStream\n    implements Syncable, CanSetDropBehind, StreamCapabilities,\n      IOStatisticsSource, Abortable {\n  private final OutputStream wrappedStream;\n\n  private static class PositionCache extends FilterOutputStream {\n    private final FileSystem.Statistics statistics;\n    private long position;\n\n    PositionCache(OutputStream out, FileSystem.Statistics stats, long pos) {\n      super(out);\n      statistics = stats;\n      position = pos;\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n      out.write(b);\n      position++;\n      if (statistics != null) {\n        statistics.incrementBytesWritten(1);\n      }\n    }\n    \n    @Override\n    public void write(byte b[], int off, int len) throws IOException {\n      out.write(b, off, len);\n      position += len;                            // update position\n      if (statistics != null) {\n        statistics.incrementBytesWritten(len);\n      }\n    }\n      \n    long getPos() {\n      return position;                            // return cached position\n    }\n\n    @Override\n    public void close() throws IOException {\n      // ensure close works even if a null reference was passed in\n      if (out != null) {\n        out.close();\n      }\n    }\n  }\n\n  public FSDataOutputStream(OutputStream out, FileSystem.Statistics stats) {\n    this(out, stats, 0);\n  }\n\n  public FSDataOutputStream(OutputStream out, FileSystem.Statistics stats,\n                            long startPosition) {\n    super(new PositionCache(out, stats, startPosition));\n    wrappedStream = out;\n  }\n  \n  /**\n   * Get the current position in the output stream.\n   *\n   * @return the current position in the output stream\n   */\n  public long getPos() {\n    return ((PositionCache)out).getPos();\n  }\n\n  /**\n   * Close the underlying output stream.\n   */\n  @Override\n  public void close() throws IOException {\n    out.close(); // This invokes PositionCache.close()\n  }\n\n  @Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder(\n        \"FSDataOutputStream{\");\n    sb.append(\"wrappedStream=\").append(wrappedStream)\n        .append('}');\n    return sb.toString();\n  }\n\n  /**\n   * Get a reference to the wrapped output stream.\n   *\n   * @return the underlying output stream\n   */\n  @InterfaceAudience.LimitedPrivate({\"HDFS\"})\n  public OutputStream getWrappedStream() {\n    return wrappedStream;\n  }\n\n  @Override\n  public boolean hasCapability(String capability) {\n    return StoreImplementationUtils.hasCapability(wrappedStream, capability);\n  }\n\n  @Override  // Syncable\n  public void hflush() throws IOException {\n    if (wrappedStream instanceof Syncable) {\n      ((Syncable)wrappedStream).hflush();\n    } else {\n      wrappedStream.flush();\n    }\n  }\n  \n  @Override  // Syncable\n  public void hsync() throws IOException {\n    if (wrappedStream instanceof Syncable) {\n      ((Syncable)wrappedStream).hsync();\n    } else {\n      wrappedStream.flush();\n    }\n  }\n\n  @Override\n  public void setDropBehind(Boolean dropBehind) throws IOException {\n    try {\n      ((CanSetDropBehind)wrappedStream).setDropBehind(dropBehind);\n    } catch (ClassCastException e) {\n      throw new UnsupportedOperationException(\"the wrapped stream does \" +\n          \"not support setting the drop-behind caching setting.\");\n    }\n  }\n\n  /**\n   * Get the IO Statistics of the nested stream, falling back to\n   * empty statistics if the stream does not implement the interface\n   * {@link IOStatisticsSource}.\n   * @return an IOStatistics instance.\n   */\n  @Override\n  public IOStatistics getIOStatistics() {\n    return IOStatisticsSupport.retrieveIOStatistics(wrappedStream);\n  }\n\n  /**\n   * Invoke {@code abort()} on the wrapped stream if it\n   * is Abortable, otherwise raise an\n   * {@code UnsupportedOperationException}.\n   * @throws UnsupportedOperationException if not available.\n   * @return the result.\n   */\n  @Override\n  public AbortableResult abort() {\n    if (wrappedStream instanceof Abortable) {\n      return ((Abortable) wrappedStream).abort();\n    } else {\n      throw new UnsupportedOperationException(\n          FSExceptionMessages.ABORTABLE_UNSUPPORTED);\n    }\n  }\n}\n"
    },
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\AWD\\apache\\hadoop\\commit_1200\\2245\\before\\hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/HdfsDataOutputStream.java",
      "chunk_type": "subType",
      "ast_subtree": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.client;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.EnumSet;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.crypto.CryptoOutputStream;\nimport org.apache.hadoop.fs.FSDataOutputStream;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.hdfs.DFSOutputStream;\n\nimport org.apache.hadoop.util.Preconditions;\n\n/**\n * The Hdfs implementation of {@link FSDataOutputStream}.\n */\n@InterfaceAudience.Public\n@InterfaceStability.Evolving\npublic class HdfsDataOutputStream extends FSDataOutputStream {\n  public HdfsDataOutputStream(DFSOutputStream out, FileSystem.Statistics stats,\n      long startPosition) throws IOException {\n    super(out, stats, startPosition);\n  }\n\n  public HdfsDataOutputStream(DFSOutputStream out, FileSystem.Statistics stats)\n      throws IOException {\n    this(out, stats, 0L);\n  }\n\n  public HdfsDataOutputStream(CryptoOutputStream out,\n      FileSystem.Statistics stats, long startPosition) throws IOException {\n    super(out, stats, startPosition);\n    Preconditions.checkArgument(\n        out.getWrappedStream() instanceof DFSOutputStream,\n        \"CryptoOutputStream should wrap a DFSOutputStream\");\n  }\n\n  public HdfsDataOutputStream(CryptoOutputStream out,\n      FileSystem.Statistics stats) throws IOException {\n    this(out, stats, 0L);\n  }\n\n  /**\n   * Get the actual number of replicas of the current block.\n   *\n   * This can be different from the designated replication factor of the file\n   * because the namenode does not maintain replication for the blocks which are\n   * currently being written to. Depending on the configuration, the client may\n   * continue to write to a block even if a few datanodes in the write pipeline\n   * have failed, or the client may add a new datanodes once a datanode has\n   * failed.\n   *\n   * @return the number of valid replicas of the current block\n   */\n  public synchronized int getCurrentBlockReplication() throws IOException {\n    OutputStream wrappedStream = getWrappedStream();\n    if (wrappedStream instanceof CryptoOutputStream) {\n      wrappedStream = ((CryptoOutputStream) wrappedStream).getWrappedStream();\n    }\n    return ((DFSOutputStream) wrappedStream).getCurrentBlockReplication();\n  }\n\n  /**\n   * Sync buffered data to DataNodes (flush to disk devices).\n   *\n   * @param syncFlags\n   *          Indicate the detailed semantic and actions of the hsync.\n   * @throws IOException\n   * @see FSDataOutputStream#hsync()\n   */\n  public void hsync(EnumSet<SyncFlag> syncFlags) throws IOException {\n    OutputStream wrappedStream = getWrappedStream();\n    if (wrappedStream instanceof CryptoOutputStream) {\n      wrappedStream.flush();\n      wrappedStream = ((CryptoOutputStream) wrappedStream).getWrappedStream();\n    }\n    ((DFSOutputStream) wrappedStream).hsync(syncFlags);\n  }\n\n  public enum SyncFlag {\n\n    /**\n     * When doing sync to DataNodes, also update the metadata (block length) in\n     * the NameNode.\n     */\n    UPDATE_LENGTH,\n\n    /**\n     * Sync the data to DataNode, close the current block, and allocate a new\n     * block\n     */\n    END_BLOCK\n  }\n}\n"
    }
  ]
}