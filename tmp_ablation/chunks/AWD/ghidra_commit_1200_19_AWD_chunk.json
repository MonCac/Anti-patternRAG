{
  "antipattern_type": "AWD",
  "project_name": "ghidra",
  "commit_number": "commit_1200",
  "id": "19",
  "group_id": 0,
  "chunks": [
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\AWD\\apache\\ghidra\\commit_1200\\19\\before\\Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/decompiler/taint/TaintState.java",
      "chunk_type": "clientClass",
      "ast_subtree": "/* ###\n * IP: GHIDRA\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage ghidra.app.plugin.core.decompiler.taint;\n\nimport java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.util.*;\n\nimport com.contrastsecurity.sarif.SarifSchema210;\n\nimport ghidra.app.decompiler.*;\nimport ghidra.app.script.GhidraScript;\nimport ghidra.app.services.ConsoleService;\nimport ghidra.framework.plugintool.PluginTool;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.address.AddressSet;\nimport ghidra.program.model.listing.Program;\nimport ghidra.program.model.pcode.*;\nimport ghidra.program.model.symbol.Symbol;\nimport ghidra.program.model.symbol.SymbolTable;\nimport ghidra.util.Msg;\nimport ghidra.util.classfinder.ClassSearcher;\nimport ghidra.util.classfinder.ExtensionPoint;\n\n/**\n * The interface for the methods that collect desired taint information from the decompiler window and store them\n * for construction of queries and indexing.\n * <p>\n * NOTE:  ALL TaintState CLASSES MUST END IN \"TaintState\".  If not,\n * the ClassSearcher will not find them.\n */\npublic interface TaintState extends ExtensionPoint {\n\n\tpublic enum MarkType {\n\t\tSOURCE, SINK, GATE\n\t}\n\n\tpublic enum QueryType {\n\t\tSRCSINK, DEFAULT, CUSTOM\n\t}\n\n\tpublic enum TaskType {\n\t\tSET_TAINT, SET_DELTA, APPLY_DELTA\n\t}\n\n\tpublic static TaintState newInstance(TaintPlugin plugin, String type) {\n\t\tList<Class<? extends TaintState>> list = ClassSearcher.getClasses(TaintState.class)\n\t\t\t\t.stream()\n\t\t\t\t.toList();\n\t\tClass<?>[] constructorArgumentTypes = {TaintPlugin.class};\n\t\tObject[] args = new Object[1];\n\t\targs[0] = plugin;\n\t\tfor (Class<? extends TaintState> clazz : list) {\n\t\t\tif (clazz.getName().toLowerCase().contains(type)) {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> constructor = clazz.getConstructor(constructorArgumentTypes);\n\t\t\t\t\tObject obj = constructor.newInstance(plugin);\n\t\t\t\t\treturn TaintState.class.cast(obj);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException(\"Unable to instantiate TaintState\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMsg.error(plugin, \"No match for engine = \"+type);\n\t\treturn null;\n\t}\n\n\tpublic String getName();\n\n\t/**\n\t * Perform a Source-Sink query on the index database.\n\t * \n\t * @param program the program whose pcode is being queried.\n\t * @param tool - \n\t * @param queryType true -> perform the default query (i.e., do not build the query from the selected source) \n\t * @return success\n\t */\n\tpublic boolean queryIndex(Program program, PluginTool tool, QueryType queryType);\n\n\tpublic TaintLabel toggleMark(MarkType mtype, ClangToken token) throws PcodeException;\n\n\tpublic Set<TaintLabel> getTaintLabels(MarkType mtype);\n\n\tpublic boolean isValid();\n\n\tpublic AddressSet getTaintAddressSet();\n\n\tpublic void setTaintAddressSet(AddressSet aset);\n\n\tpublic void augmentAddressSet(ClangToken token);\n\n\tpublic void clearTaint();\n\n\tpublic boolean isSink(HighVariable hvar);\n\n\tpublic void clearMarkers();\n\n\tpublic void loadTaintData(Program program, File sarif_file);\n\n\tpublic SarifSchema210 getData();\n\n\tpublic void clearData();\n\n\tpublic TaintOptions getOptions();\n\n\t// predicate that indicates there are sources, sinks, or gates.\n\tpublic boolean hasMarks();\n\n\tpublic boolean wasCancelled();\n\n\tpublic void setCancellation(boolean status);\n\n\tpublic void setTaintVarnodeMap(Map<Address, Set<TaintQueryResult>> vmap, TaskType delta);\n\n\tpublic Map<Address, Set<TaintQueryResult>> getTaintVarnodeMap();\n\n\tpublic Set<TaintQueryResult> getQuerySet(Address addr);\n\n\tpublic void buildIndex(List<String> param_list, String engine_path, String facts_path,\n\t\t\tString index_directory);\n\n\tpublic GhidraScript getExportScript(ConsoleService console, boolean perFunction);\n\n\tpublic void setTaskType(TaskType taskType);\n\n\tpublic TaintLabel getLabelForToken(MarkType type, ClangToken token);\n\n\tpublic static String hvarName(ClangToken token) {\n\t\tHighVariable hv = token.getHighVariable();\n\t\tHighFunction hf =\n\t\t\t(hv == null) ? token.getClangFunction().getHighFunction() : hv.getHighFunction();\n\t\tif (hv == null || hv.getName() == null || hv.getName().equals(\"UNNAMED\")) {\n\t\t\tSymbolTable symbolTable = hf.getFunction().getProgram().getSymbolTable();\n\t\t\tVarnode rep = hv.getRepresentative();\n\t\t\tAddress addr = rep.getAddress();\n\t\t\tSymbol symbol = symbolTable.getPrimarySymbol(addr);\n\t\t\tif (symbol == null) {\n\t\t\t\tif (hv instanceof HighLocal) {\n\t\t\t\t\treturn addr.toString();\n\t\t\t\t}\n\t\t\t\treturn token.getText();\n\t\t\t}\n\t\t\treturn symbol.getName();\n\t\t}\n\t\treturn hv.getName();\n\t}\n\n\tpublic static ClangVariableToken getParentToken(ClangFieldToken token) {\n\t\tClangTokenGroup group = (ClangTokenGroup) token.Parent();\n\t\tIterator<ClangNode> iterator = group.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tClangNode next = iterator.next();\n\t\t\tif (next instanceof ClangVariableToken vtoken) {\n\t\t\t\tHighVariable highVariable = vtoken.getHighVariable();\n\t\t\t\tif (highVariable == null || highVariable instanceof HighConstant) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn vtoken;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static boolean isActualParam(ClangToken token) {\n\t\tPcodeOp pcodeOp = token.getPcodeOp();\n\t\tif (pcodeOp != null) {\n\t\t\tString mnemonic = pcodeOp.getMnemonic();\n\t\t\tif (mnemonic.contains(\"CALL\")) {\n\t\t\t\tfor (Varnode input : pcodeOp.getInputs()) {\n\t\t\t\t\tif (input.equals(token.getVarnode())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}\n"
    },
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\AWD\\apache\\ghidra\\commit_1200\\19\\before\\Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/ClangTokenGroup.java",
      "chunk_type": "superType",
      "ast_subtree": "/* ###\n * IP: GHIDRA\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage ghidra.app.decompiler;\n\nimport static ghidra.program.model.pcode.ElementId.*;\n\nimport java.awt.Color;\nimport java.util.*;\nimport java.util.stream.Stream;\n\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.pcode.*;\n\n/**\n * A sequence of tokens that form a meaningful group in source code.  This group may\n * break up into subgroups and may be part of a larger group.\n */\npublic class ClangTokenGroup implements ClangNode, Iterable<ClangNode> {\n\tprivate ClangNode parent;\n\tAddress minaddress, maxaddress;\n\tprivate ArrayList<ClangNode> tokgroup;\n\n\tpublic ClangTokenGroup(ClangNode par) {\n\t\tparent = par;\n\t\ttokgroup = new ArrayList<>();\n\t\tminaddress = null;\n\t\tmaxaddress = null;\n\t}\n\n\t@Override\n\tpublic Address getMinAddress() {\n\t\treturn minaddress;\n\t}\n\n\t@Override\n\tpublic Address getMaxAddress() {\n\t\treturn maxaddress;\n\t}\n\n\t/**\n\t * Add additional text to this group\n\t * @param obj is the additional text\n\t */\n\tpublic void AddTokenGroup(ClangNode obj) {\n\t\tAddress minaddr = obj.getMinAddress();\n\t\tAddress maxaddr = obj.getMaxAddress();\n\n\t\tif (minaddr != null) {\n\t\t\tif (minaddress == null) {\n\t\t\t\tminaddress = minaddr;\n\t\t\t}\n\t\t\telse if (minaddr.compareTo(minaddress) < 0) {\n\t\t\t\tminaddress = minaddr;\n\t\t\t}\n\t\t}\n\t\tif (maxaddr != null) {\n\t\t\tif (maxaddress == null) {\n\t\t\t\tmaxaddress = maxaddr;\n\t\t\t}\n\t\t\telse if (maxaddress.compareTo(maxaddr) < 0) {\n\t\t\t\tmaxaddress = maxaddr;\n\t\t\t}\n\t\t}\n\t\ttokgroup.add(obj);\n\t}\n\n\t@Override\n\tpublic ClangNode Parent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic int numChildren() {\n\t\treturn tokgroup.size();\n\t}\n\n\t@Override\n\tpublic ClangNode Child(int i) {\n\t\treturn tokgroup.get(i);\n\t}\n\n\t@Override\n\tpublic ClangFunction getClangFunction() {\n\t\treturn parent.getClangFunction();\n\t}\n\n\t@Override\n\tpublic void setHighlight(Color val) {\n\t\tfor (ClangNode element : tokgroup) {\n\t\t\telement.setHighlight(val);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void flatten(List<ClangNode> list) {\n\t\tfor (ClangNode element : tokgroup) {\n\t\t\telement.flatten(list);\n\t\t}\n\t}\n\n\t/**\n\t * Decode this text from an encoded stream.\n\t * @param decoder is the decoder for the stream\n\t * @param pfactory is used to look up p-code attributes to associate with tokens\n\t * @throws DecoderException for problems decoding the stream\n\t */\n\tpublic void decode(Decoder decoder, PcodeFactory pfactory) throws DecoderException {\n\t\tfor (;;) {\n\t\t\tint elem = decoder.openElement();\n\t\t\tif (elem == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (elem == ELEM_RETURN_TYPE.id()) {\n\t\t\t\tClangReturnType child = new ClangReturnType(this);\n\t\t\t\tchild.decode(decoder, pfactory);\n\t\t\t\tAddTokenGroup(child);\n\t\t\t}\n\t\t\telse if (elem == ELEM_VARDECL.id()) {\n\t\t\t\tClangVariableDecl child = new ClangVariableDecl(this);\n\t\t\t\tchild.decode(decoder, pfactory);\n\t\t\t\tAddTokenGroup(child);\n\t\t\t}\n\t\t\telse if (elem == ELEM_STATEMENT.id()) {\n\t\t\t\tClangStatement child = new ClangStatement(this);\n\t\t\t\tchild.decode(decoder, pfactory);\n\t\t\t\tAddTokenGroup(child);\n\t\t\t}\n\t\t\telse if (elem == ELEM_FUNCPROTO.id()) {\n\t\t\t\tClangFuncProto child = new ClangFuncProto(this);\n\t\t\t\tchild.decode(decoder, pfactory);\n\t\t\t\tAddTokenGroup(child);\n\t\t\t}\n\t\t\telse if (elem == ELEM_BLOCK.id()) {\n\t\t\t\tClangTokenGroup child = new ClangTokenGroup(this);\n\t\t\t\tchild.decode(decoder, pfactory);\n\t\t\t\tAddTokenGroup(child);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClangToken tok = ClangToken.buildToken(elem, this, decoder, pfactory);\n\t\t\t\tAddTokenGroup(tok);\n\t\t\t}\n\t\t\tdecoder.closeElement(elem);\n\t\t}\n\t}\n\n\t/**\n\t * @param c is a character\n\t * @return true if the given character is a letter, digit, or underscore\n\t */\n\tprivate static boolean isLetterDigitOrUnderscore(char c) {\n\t\treturn Character.isLetterOrDigit(c) || c == '_';\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tString lastTokenStr = null;\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tIterator<ClangNode> iter = tokgroup.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tClangNode node = iter.next();\n\t\t\tString tokenStr = node.toString();\n\t\t\tif (tokenStr.length() == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastTokenStr != null && isLetterDigitOrUnderscore(tokenStr.charAt(0)) &&\n\t\t\t\tisLetterDigitOrUnderscore(lastTokenStr.charAt(lastTokenStr.length() - 1))) {\n\t\t\t\t// avoid concatenating names together\n\t\t\t\tbuffer.append(' ');\n\t\t\t}\n\t\t\tlastTokenStr = tokenStr;\n\t\t\tbuffer.append(tokenStr);\n\t\t}\n\t\treturn buffer.toString();\n\t}\n\n\t@Override\n\tpublic Iterator<ClangNode> iterator() {\n\t\treturn tokgroup.iterator();\n\t}\n\n\t/**\n\t * Create iterator across all ClangToken objects in this group.\n\t * The iterator will run over tokens in display order (forward=true) or in reverse of\n\t * display order (forward=false)\n\t * @param forward is true for a forward iterator, false for a backward iterator\n\t * @return the iterator\n\t */\n\tpublic Iterator<ClangToken> tokenIterator(boolean forward) {\n\t\treturn new TokenIterator(this, forward);\n\t}\n\n\t/**\n\t * Gets a stream over this group's children\n\t * @return a stream of this group's children\n\t */\n\tpublic Stream<ClangNode> stream() {\n\t\treturn tokgroup.stream();\n\t}\n}\n"
    },
    {
      "file_path": "D:\\Disaster\\Codefield\\Code_Python\\Anti-patternRAG\\data\\AWD\\apache\\ghidra\\commit_1200\\19\\before\\Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/ClangFunction.java",
      "chunk_type": "subType",
      "ast_subtree": "/* ###\n * IP: GHIDRA\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage ghidra.app.decompiler;\n\nimport ghidra.program.model.pcode.HighFunction;\n\n/**\n * A grouping of source code tokens representing an entire function\n */\npublic class ClangFunction extends ClangTokenGroup {\n\tprivate final HighFunction hfunc;\n\n\tpublic ClangFunction(ClangNode parent, HighFunction hfunc) {\n\t\tsuper(parent);\n\t\tthis.hfunc = hfunc;\n\t}\n\n\t@Override\n\tpublic ClangFunction getClangFunction() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return the HighFunction object represented by this source code\n\t */\n\tpublic HighFunction getHighFunction() {\n\t\treturn hfunc;\n\t}\n}\n"
    }
  ]
}