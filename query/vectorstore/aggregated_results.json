{
  "3": {
    "score": 0.8162465393543245,
    "path": "data/CH/kafka/commit_1000/20",
    "files": {
      "kafka_20_ch_antipattern.json": "{\n  \"superClass\": \"org.apache.kafka.common.requests.AbstractResponse\",\n  \"subClass\": \"org.apache.kafka.common.requests.LeaderAndIsrResponse\",\n  \"files\": [\n    \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n    \"clients/src/main/java/org/apache/kafka/common/requests/LeaderAndIsrResponse.java\"\n  ],\n  \"dependencyChain\": [\n    {\n      \"from\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n      \"to\": \"org.apache.kafka.common.requests.LeaderAndIsrResponse.parse\",\n      \"relationType\": \"Call\"\n    }\n  ],\n  \"codeSnippets\": [\n    {\n      \"fromFile\": \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n      \"toFile\": \"clients/src/main/java/org/apache/kafka/common/requests/LeaderAndIsrResponse.java\",\n      \"relationType\": \"Call\",\n      \"parentMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n        \"location\": \"112–300\",\n        \"code\": \"public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\\n        switch (apiKey) {\\n            case PRODUCE:\\n                return ProduceResponse.parse(responseBuffer, version);\\n            case FETCH:\\n                return FetchResponse.parse(responseBuffer, version);\\n            case LIST_OFFSETS:\\n                return ListOffsetsResponse.parse(responseBuffer, version);\\n            case METADATA:\\n                return MetadataResponse.parse(responseBuffer, version);\\n            case OFFSET_COMMIT:\\n                return OffsetCommitResponse.parse(responseBuffer, version);\\n            case OFFSET_FETCH:\\n                return OffsetFetchResponse.parse(responseBuffer, version);\\n            case FIND_COORDINATOR:\\n                return FindCoordinatorResponse.parse(responseBuffer, version);\\n            case JOIN_GROUP:\\n                return JoinGroupResponse.parse(responseBuffer, version);\\n            case HEARTBEAT:\\n                return HeartbeatResponse.parse(responseBuffer, version);\\n            case LEAVE_GROUP:\\n                return LeaveGroupResponse.parse(responseBuffer, version);\\n            case SYNC_GROUP:\\n                return SyncGroupResponse.parse(responseBuffer, version);\\n            case STOP_REPLICA:\\n                return StopReplicaResponse.parse(responseBuffer, version);\\n            case CONTROLLED_SHUTDOWN:\\n                return ControlledShutdownResponse.parse(responseBuffer, version);\\n            case UPDATE_METADATA:\\n                return UpdateMetadataResponse.parse(responseBuffer, version);\\n            case LEADER_AND_ISR:\\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\\n            case DESCRIBE_GROUPS:\\n                return DescribeGroupsResponse.parse(responseBuffer, version);\\n            case LIST_GROUPS:\\n                return ListGroupsResponse.parse(responseBuffer, version);\\n            case SASL_HANDSHAKE:\\n                return SaslHandshakeResponse.parse(responseBuffer, version);\\n            case API_VERSIONS:\\n                return ApiVersionsResponse.parse(responseBuffer, version);\\n            case CREATE_TOPICS:\\n                return CreateTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_TOPICS:\\n                return DeleteTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_RECORDS:\\n                return DeleteRecordsResponse.parse(responseBuffer, version);\\n            case INIT_PRODUCER_ID:\\n                return InitProducerIdResponse.parse(responseBuffer, version);\\n            case OFFSET_FOR_LEADER_EPOCH:\\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\\n            case ADD_PARTITIONS_TO_TXN:\\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\\n            case ADD_OFFSETS_TO_TXN:\\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\\n            case END_TXN:\\n                return EndTxnResponse.parse(responseBuffer, version);\\n            case WRITE_TXN_MARKERS:\\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\\n            case TXN_OFFSET_COMMIT:\\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\\n            case DESCRIBE_ACLS:\\n                return DescribeAclsResponse.parse(responseBuffer, version);\\n            case CREATE_ACLS:\\n                return CreateAclsResponse.parse(responseBuffer, version);\\n            case DELETE_ACLS:\\n                return DeleteAclsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CONFIGS:\\n                return DescribeConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_CONFIGS:\\n                return AlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_REPLICA_LOG_DIRS:\\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_LOG_DIRS:\\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\\n            case SASL_AUTHENTICATE:\\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\\n            case CREATE_PARTITIONS:\\n                return CreatePartitionsResponse.parse(responseBuffer, version);\\n            case CREATE_DELEGATION_TOKEN:\\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\\n            case RENEW_DELEGATION_TOKEN:\\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\\n            case EXPIRE_DELEGATION_TOKEN:\\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\\n            case DESCRIBE_DELEGATION_TOKEN:\\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\\n            case DELETE_GROUPS:\\n                return DeleteGroupsResponse.parse(responseBuffer, version);\\n            case ELECT_LEADERS:\\n                return ElectLeadersResponse.parse(responseBuffer, version);\\n            case INCREMENTAL_ALTER_CONFIGS:\\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION_REASSIGNMENTS:\\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case LIST_PARTITION_REASSIGNMENTS:\\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case OFFSET_DELETE:\\n                return OffsetDeleteResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLIENT_QUOTAS:\\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\\n            case ALTER_CLIENT_QUOTAS:\\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case ALTER_USER_SCRAM_CREDENTIALS:\\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case VOTE:\\n                return VoteResponse.parse(responseBuffer, version);\\n            case BEGIN_QUORUM_EPOCH:\\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\\n            case END_QUORUM_EPOCH:\\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\\n            case DESCRIBE_QUORUM:\\n                return DescribeQuorumResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION:\\n                return AlterPartitionResponse.parse(responseBuffer, version);\\n            case UPDATE_FEATURES:\\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\\n            case ENVELOPE:\\n                return EnvelopeResponse.parse(responseBuffer, version);\\n            case FETCH_SNAPSHOT:\\n                return FetchSnapshotResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLUSTER:\\n                return DescribeClusterResponse.parse(responseBuffer, version);\\n            case DESCRIBE_PRODUCERS:\\n                return DescribeProducersResponse.parse(responseBuffer, version);\\n            case BROKER_REGISTRATION:\\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\\n            case BROKER_HEARTBEAT:\\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\\n            case UNREGISTER_BROKER:\\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TRANSACTIONS:\\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\\n            case LIST_TRANSACTIONS:\\n                return ListTransactionsResponse.parse(responseBuffer, version);\\n            case ALLOCATE_PRODUCER_IDS:\\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_HEARTBEAT:\\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_DESCRIBE:\\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\\n            case CONTROLLER_REGISTRATION:\\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\\n            case GET_TELEMETRY_SUBSCRIPTIONS:\\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\\n            case PUSH_TELEMETRY:\\n                return PushTelemetryResponse.parse(responseBuffer, version);\\n            case ASSIGN_REPLICAS_TO_DIRS:\\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\\n            case LIST_CLIENT_METRICS_RESOURCES:\\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TOPIC_PARTITIONS:\\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_HEARTBEAT:\\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_DESCRIBE:\\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\\n            case SHARE_FETCH:\\n                return ShareFetchResponse.parse(responseBuffer, version);\\n            case SHARE_ACKNOWLEDGE:\\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\\n            case ADD_RAFT_VOTER:\\n                return AddRaftVoterResponse.parse(responseBuffer, version);\\n            case REMOVE_RAFT_VOTER:\\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\\n            case UPDATE_RAFT_VOTER:\\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\\n            case INITIALIZE_SHARE_GROUP_STATE:\\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE:\\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\\n            case WRITE_SHARE_GROUP_STATE:\\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\\n            case DELETE_SHARE_GROUP_STATE:\\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE_SUMMARY:\\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_HEARTBEAT:\\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_DESCRIBE:\\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\\n            default:\\n                throw new AssertionError(String.format(\\\"ApiKey %s is not currently handled in `parseResponse`, the \\\" +\\n                        \\\"code should be updated to do so.\\\", apiKey));\\n        }\\n    }\"\n      },\n      \"childMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.LeaderAndIsrResponse.parse\",\n        \"location\": \"107–109\",\n        \"code\": \"public static LeaderAndIsrResponse parse(ByteBuffer buffer, short version) {\\n        return new LeaderAndIsrResponse(new LeaderAndIsrResponseData(new ByteBufferAccessor(buffer), version), version);\\n    }\"\n      },\n      \"invocation\": {\n        \"location\": \"143–143\",\n        \"code\": \"return LeaderAndIsrResponse.parse(responseBuffer, version);\"\n      }\n    }\n  ]\n}",
      "before/clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic abstract class AbstractResponse implements AbstractRequestResponse {\n    public static final int DEFAULT_THROTTLE_TIME = 0;\n\n    private final ApiKeys apiKey;\n\n    protected AbstractResponse(ApiKeys apiKey) {\n        this.apiKey = apiKey;\n    }\n\n    public final Send toSend(ResponseHeader header, short version) {\n        return SendBuilder.buildResponseSend(header, data(), version);\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    final ByteBuffer serializeWithHeader(ResponseHeader header, short version) {\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    final ByteBuffer serialize(short version) {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    /**\n     * The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as\n     * more specifically scoped errors (such as topic or partition-level errors).\n     * @return A count of errors.\n     */\n    public abstract Map<Errors, Integer> errorCounts();\n\n    protected Map<Errors, Integer> errorCounts(Errors error) {\n        return Collections.singletonMap(error, 1);\n    }\n\n    protected Map<Errors, Integer> errorCounts(Stream<Errors> errors) {\n        return errors.collect(Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1)));\n    }\n\n    protected Map<Errors, Integer> errorCounts(Collection<Errors> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (Errors error : errors)\n            updateErrorCounts(errorCounts, error);\n        return errorCounts;\n    }\n\n    protected Map<Errors, Integer> apiErrorCounts(Map<?, ApiError> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (ApiError apiError : errors.values())\n            updateErrorCounts(errorCounts, apiError.error());\n        return errorCounts;\n    }\n\n    protected void updateErrorCounts(Map<Errors, Integer> errorCounts, Errors error) {\n        Integer count = errorCounts.getOrDefault(error, 0);\n        errorCounts.put(error, count + 1);\n    }\n\n    /**\n     * Parse a response from the provided buffer. The buffer is expected to hold both\n     * the {@link ResponseHeader} as well as the response payload.\n     */\n    public static AbstractResponse parseResponse(ByteBuffer buffer, RequestHeader requestHeader) {\n        ApiKeys apiKey = requestHeader.apiKey();\n        short apiVersion = requestHeader.apiVersion();\n\n        ResponseHeader responseHeader = ResponseHeader.parse(buffer, apiKey.responseHeaderVersion(apiVersion));\n\n        if (requestHeader.correlationId() != responseHeader.correlationId()) {\n            throw new CorrelationIdMismatchException(\"Correlation id for response (\"\n                + responseHeader.correlationId() + \") does not match request (\"\n                + requestHeader.correlationId() + \"), request header: \" + requestHeader,\n                requestHeader.correlationId(), responseHeader.correlationId());\n        }\n\n        return AbstractResponse.parseResponse(apiKey, buffer, apiVersion);\n    }\n\n    public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceResponse.parse(responseBuffer, version);\n            case FETCH:\n                return FetchResponse.parse(responseBuffer, version);\n            case LIST_OFFSETS:\n                return ListOffsetsResponse.parse(responseBuffer, version);\n            case METADATA:\n                return MetadataResponse.parse(responseBuffer, version);\n            case OFFSET_COMMIT:\n                return OffsetCommitResponse.parse(responseBuffer, version);\n            case OFFSET_FETCH:\n                return OffsetFetchResponse.parse(responseBuffer, version);\n            case FIND_COORDINATOR:\n                return FindCoordinatorResponse.parse(responseBuffer, version);\n            case JOIN_GROUP:\n                return JoinGroupResponse.parse(responseBuffer, version);\n            case HEARTBEAT:\n                return HeartbeatResponse.parse(responseBuffer, version);\n            case LEAVE_GROUP:\n                return LeaveGroupResponse.parse(responseBuffer, version);\n            case SYNC_GROUP:\n                return SyncGroupResponse.parse(responseBuffer, version);\n            case STOP_REPLICA:\n                return StopReplicaResponse.parse(responseBuffer, version);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownResponse.parse(responseBuffer, version);\n            case UPDATE_METADATA:\n                return UpdateMetadataResponse.parse(responseBuffer, version);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsResponse.parse(responseBuffer, version);\n            case LIST_GROUPS:\n                return ListGroupsResponse.parse(responseBuffer, version);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeResponse.parse(responseBuffer, version);\n            case API_VERSIONS:\n                return ApiVersionsResponse.parse(responseBuffer, version);\n            case CREATE_TOPICS:\n                return CreateTopicsResponse.parse(responseBuffer, version);\n            case DELETE_TOPICS:\n                return DeleteTopicsResponse.parse(responseBuffer, version);\n            case DELETE_RECORDS:\n                return DeleteRecordsResponse.parse(responseBuffer, version);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdResponse.parse(responseBuffer, version);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\n            case END_TXN:\n                return EndTxnResponse.parse(responseBuffer, version);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\n            case DESCRIBE_ACLS:\n                return DescribeAclsResponse.parse(responseBuffer, version);\n            case CREATE_ACLS:\n                return CreateAclsResponse.parse(responseBuffer, version);\n            case DELETE_ACLS:\n                return DeleteAclsResponse.parse(responseBuffer, version);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsResponse.parse(responseBuffer, version);\n            case ALTER_CONFIGS:\n                return AlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsResponse.parse(responseBuffer, version);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\n            case DELETE_GROUPS:\n                return DeleteGroupsResponse.parse(responseBuffer, version);\n            case ELECT_LEADERS:\n                return ElectLeadersResponse.parse(responseBuffer, version);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case OFFSET_DELETE:\n                return OffsetDeleteResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\n            case VOTE:\n                return VoteResponse.parse(responseBuffer, version);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION:\n                return AlterPartitionResponse.parse(responseBuffer, version);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\n            case ENVELOPE:\n                return EnvelopeResponse.parse(responseBuffer, version);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterResponse.parse(responseBuffer, version);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersResponse.parse(responseBuffer, version);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsResponse.parse(responseBuffer, version);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\n            case PUSH_TELEMETRY:\n                return PushTelemetryResponse.parse(responseBuffer, version);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\n            case SHARE_FETCH:\n                return ShareFetchResponse.parse(responseBuffer, version);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterResponse.parse(responseBuffer, version);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseResponse`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n\n    /**\n     * Returns whether or not client should throttle upon receiving a response of the specified version with a non-zero\n     * throttle time. Client-side throttling is needed when communicating with a newer version of broker which, on\n     * quota violation, sends out responses before throttling.\n     */\n    public boolean shouldClientThrottle(short version) {\n        return false;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    /**\n     * Get the throttle time in milliseconds. If the response schema does not\n     * support this field, then 0 will be returned.\n     */\n    public abstract int throttleTimeMs();\n\n    /**\n     * Set the throttle time in the response if the schema supports it. Otherwise,\n     * this is a no-op.\n     *\n     * @param throttleTimeMs The throttle time in milliseconds\n     */\n    public abstract void maybeSetThrottleTimeMs(int throttleTimeMs);\n\n    public String toString() {\n        return data().toString();\n    }\n}\n",
      "before/clients/src/main/java/org/apache/kafka/common/requests/LeaderAndIsrResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.Uuid;\nimport org.apache.kafka.common.message.LeaderAndIsrResponseData;\nimport org.apache.kafka.common.message.LeaderAndIsrResponseData.LeaderAndIsrTopicError;\nimport org.apache.kafka.common.message.LeaderAndIsrResponseData.LeaderAndIsrTopicErrorCollection;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LeaderAndIsrResponse extends AbstractResponse {\n\n    /**\n     * Possible error code:\n     *\n     * STALE_CONTROLLER_EPOCH (11)\n     * STALE_BROKER_EPOCH (77)\n     */\n    private final LeaderAndIsrResponseData data;\n    private final short version;\n\n    public LeaderAndIsrResponse(LeaderAndIsrResponseData data, short version) {\n        super(ApiKeys.LEADER_AND_ISR);\n        this.data = data;\n        this.version = version;\n    }\n\n    public LeaderAndIsrTopicErrorCollection topics() {\n        return this.data.topics();\n    }\n\n    public Errors error() {\n        return Errors.forCode(data.errorCode());\n    }\n\n    @Override\n    public Map<Errors, Integer> errorCounts() {\n        Errors error = error();\n        if (error != Errors.NONE) {\n            // Minor optimization since the top-level error applies to all partitions\n            if (version < 5) \n                return Collections.singletonMap(error, data.partitionErrors().size() + 1);\n            return Collections.singletonMap(error, \n                    data.topics().stream().mapToInt(t -> t.partitionErrors().size()).sum() + 1);\n        }\n        Map<Errors, Integer> errors;\n        if (version < 5)\n            errors = errorCounts(data.partitionErrors().stream().map(l -> Errors.forCode(l.errorCode())));\n        else\n            errors = errorCounts(data.topics().stream().flatMap(t -> t.partitionErrors().stream()).map(l ->\n                Errors.forCode(l.errorCode())));\n        updateErrorCounts(errors, Errors.NONE);\n        return errors;\n    }\n\n    public Map<TopicPartition, Errors> partitionErrors(Map<Uuid, String> topicNames) {\n        Map<TopicPartition, Errors> errors = new HashMap<>();\n        if (version < 5) {\n            data.partitionErrors().forEach(partition ->\n                    errors.put(new TopicPartition(partition.topicName(), partition.partitionIndex()),\n                            Errors.forCode(partition.errorCode())));\n        } else {\n            for (LeaderAndIsrTopicError topic : data.topics()) {\n                String topicName = topicNames.get(topic.topicId());\n                if (topicName != null) {\n                    topic.partitionErrors().forEach(partition ->\n                            errors.put(new TopicPartition(topicName, partition.partitionIndex()),\n                                    Errors.forCode(partition.errorCode())));\n                }\n            }\n        }\n        return errors;\n    }\n\n    @Override\n    public int throttleTimeMs() {\n        return DEFAULT_THROTTLE_TIME;\n    }\n\n    @Override\n    public void maybeSetThrottleTimeMs(int throttleTimeMs) {\n        // Not supported by the response schema\n    }\n\n    public static LeaderAndIsrResponse parse(ByteBuffer buffer, short version) {\n        return new LeaderAndIsrResponse(new LeaderAndIsrResponseData(new ByteBufferAccessor(buffer), version), version);\n    }\n\n    @Override\n    public LeaderAndIsrResponseData data() {\n        return data;\n    }\n\n    @Override\n    public String toString() {\n        return data.toString();\n    }\n\n}\n"
    }
  },
  "0": {
    "score": 0.7865552186965943,
    "path": "data/CH/kafka/commit_1000/77",
    "files": {
      "kafka_77_ch_antipattern.json": "{\n  \"superClass\": \"org.apache.kafka.common.requests.AbstractResponse\",\n  \"subClass\": \"org.apache.kafka.common.requests.StopReplicaResponse\",\n  \"files\": [\n    \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n    \"clients/src/main/java/org/apache/kafka/common/requests/StopReplicaResponse.java\"\n  ],\n  \"dependencyChain\": [\n    {\n      \"from\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n      \"to\": \"org.apache.kafka.common.requests.StopReplicaResponse.parse\",\n      \"relationType\": \"Call\"\n    }\n  ],\n  \"codeSnippets\": [\n    {\n      \"fromFile\": \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n      \"toFile\": \"clients/src/main/java/org/apache/kafka/common/requests/StopReplicaResponse.java\",\n      \"relationType\": \"Call\",\n      \"parentMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n        \"location\": \"112–300\",\n        \"code\": \"public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\\n        switch (apiKey) {\\n            case PRODUCE:\\n                return ProduceResponse.parse(responseBuffer, version);\\n            case FETCH:\\n                return FetchResponse.parse(responseBuffer, version);\\n            case LIST_OFFSETS:\\n                return ListOffsetsResponse.parse(responseBuffer, version);\\n            case METADATA:\\n                return MetadataResponse.parse(responseBuffer, version);\\n            case OFFSET_COMMIT:\\n                return OffsetCommitResponse.parse(responseBuffer, version);\\n            case OFFSET_FETCH:\\n                return OffsetFetchResponse.parse(responseBuffer, version);\\n            case FIND_COORDINATOR:\\n                return FindCoordinatorResponse.parse(responseBuffer, version);\\n            case JOIN_GROUP:\\n                return JoinGroupResponse.parse(responseBuffer, version);\\n            case HEARTBEAT:\\n                return HeartbeatResponse.parse(responseBuffer, version);\\n            case LEAVE_GROUP:\\n                return LeaveGroupResponse.parse(responseBuffer, version);\\n            case SYNC_GROUP:\\n                return SyncGroupResponse.parse(responseBuffer, version);\\n            case STOP_REPLICA:\\n                return StopReplicaResponse.parse(responseBuffer, version);\\n            case CONTROLLED_SHUTDOWN:\\n                return ControlledShutdownResponse.parse(responseBuffer, version);\\n            case UPDATE_METADATA:\\n                return UpdateMetadataResponse.parse(responseBuffer, version);\\n            case LEADER_AND_ISR:\\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\\n            case DESCRIBE_GROUPS:\\n                return DescribeGroupsResponse.parse(responseBuffer, version);\\n            case LIST_GROUPS:\\n                return ListGroupsResponse.parse(responseBuffer, version);\\n            case SASL_HANDSHAKE:\\n                return SaslHandshakeResponse.parse(responseBuffer, version);\\n            case API_VERSIONS:\\n                return ApiVersionsResponse.parse(responseBuffer, version);\\n            case CREATE_TOPICS:\\n                return CreateTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_TOPICS:\\n                return DeleteTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_RECORDS:\\n                return DeleteRecordsResponse.parse(responseBuffer, version);\\n            case INIT_PRODUCER_ID:\\n                return InitProducerIdResponse.parse(responseBuffer, version);\\n            case OFFSET_FOR_LEADER_EPOCH:\\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\\n            case ADD_PARTITIONS_TO_TXN:\\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\\n            case ADD_OFFSETS_TO_TXN:\\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\\n            case END_TXN:\\n                return EndTxnResponse.parse(responseBuffer, version);\\n            case WRITE_TXN_MARKERS:\\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\\n            case TXN_OFFSET_COMMIT:\\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\\n            case DESCRIBE_ACLS:\\n                return DescribeAclsResponse.parse(responseBuffer, version);\\n            case CREATE_ACLS:\\n                return CreateAclsResponse.parse(responseBuffer, version);\\n            case DELETE_ACLS:\\n                return DeleteAclsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CONFIGS:\\n                return DescribeConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_CONFIGS:\\n                return AlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_REPLICA_LOG_DIRS:\\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_LOG_DIRS:\\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\\n            case SASL_AUTHENTICATE:\\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\\n            case CREATE_PARTITIONS:\\n                return CreatePartitionsResponse.parse(responseBuffer, version);\\n            case CREATE_DELEGATION_TOKEN:\\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\\n            case RENEW_DELEGATION_TOKEN:\\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\\n            case EXPIRE_DELEGATION_TOKEN:\\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\\n            case DESCRIBE_DELEGATION_TOKEN:\\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\\n            case DELETE_GROUPS:\\n                return DeleteGroupsResponse.parse(responseBuffer, version);\\n            case ELECT_LEADERS:\\n                return ElectLeadersResponse.parse(responseBuffer, version);\\n            case INCREMENTAL_ALTER_CONFIGS:\\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION_REASSIGNMENTS:\\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case LIST_PARTITION_REASSIGNMENTS:\\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case OFFSET_DELETE:\\n                return OffsetDeleteResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLIENT_QUOTAS:\\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\\n            case ALTER_CLIENT_QUOTAS:\\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case ALTER_USER_SCRAM_CREDENTIALS:\\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case VOTE:\\n                return VoteResponse.parse(responseBuffer, version);\\n            case BEGIN_QUORUM_EPOCH:\\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\\n            case END_QUORUM_EPOCH:\\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\\n            case DESCRIBE_QUORUM:\\n                return DescribeQuorumResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION:\\n                return AlterPartitionResponse.parse(responseBuffer, version);\\n            case UPDATE_FEATURES:\\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\\n            case ENVELOPE:\\n                return EnvelopeResponse.parse(responseBuffer, version);\\n            case FETCH_SNAPSHOT:\\n                return FetchSnapshotResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLUSTER:\\n                return DescribeClusterResponse.parse(responseBuffer, version);\\n            case DESCRIBE_PRODUCERS:\\n                return DescribeProducersResponse.parse(responseBuffer, version);\\n            case BROKER_REGISTRATION:\\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\\n            case BROKER_HEARTBEAT:\\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\\n            case UNREGISTER_BROKER:\\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TRANSACTIONS:\\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\\n            case LIST_TRANSACTIONS:\\n                return ListTransactionsResponse.parse(responseBuffer, version);\\n            case ALLOCATE_PRODUCER_IDS:\\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_HEARTBEAT:\\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_DESCRIBE:\\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\\n            case CONTROLLER_REGISTRATION:\\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\\n            case GET_TELEMETRY_SUBSCRIPTIONS:\\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\\n            case PUSH_TELEMETRY:\\n                return PushTelemetryResponse.parse(responseBuffer, version);\\n            case ASSIGN_REPLICAS_TO_DIRS:\\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\\n            case LIST_CLIENT_METRICS_RESOURCES:\\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TOPIC_PARTITIONS:\\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_HEARTBEAT:\\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_DESCRIBE:\\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\\n            case SHARE_FETCH:\\n                return ShareFetchResponse.parse(responseBuffer, version);\\n            case SHARE_ACKNOWLEDGE:\\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\\n            case ADD_RAFT_VOTER:\\n                return AddRaftVoterResponse.parse(responseBuffer, version);\\n            case REMOVE_RAFT_VOTER:\\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\\n            case UPDATE_RAFT_VOTER:\\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\\n            case INITIALIZE_SHARE_GROUP_STATE:\\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE:\\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\\n            case WRITE_SHARE_GROUP_STATE:\\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\\n            case DELETE_SHARE_GROUP_STATE:\\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE_SUMMARY:\\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_HEARTBEAT:\\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_DESCRIBE:\\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\\n            default:\\n                throw new AssertionError(String.format(\\\"ApiKey %s is not currently handled in `parseResponse`, the \\\" +\\n                        \\\"code should be updated to do so.\\\", apiKey));\\n        }\\n    }\"\n      },\n      \"childMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.StopReplicaResponse.parse\",\n        \"location\": \"64–66\",\n        \"code\": \"public static StopReplicaResponse parse(ByteBuffer buffer, short version) {\\n        return new StopReplicaResponse(new StopReplicaResponseData(new ByteBufferAccessor(buffer), version));\\n    }\"\n      },\n      \"invocation\": {\n        \"location\": \"137–137\",\n        \"code\": \"return StopReplicaResponse.parse(responseBuffer, version);\"\n      }\n    }\n  ]\n}",
      "before/clients/src/main/java/org/apache/kafka/common/requests/StopReplicaResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.message.StopReplicaResponseData;\nimport org.apache.kafka.common.message.StopReplicaResponseData.StopReplicaPartitionError;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class StopReplicaResponse extends AbstractResponse {\n\n    /**\n     * Possible error code:\n     *  - {@link Errors#STALE_CONTROLLER_EPOCH}\n     *  - {@link Errors#STALE_BROKER_EPOCH}\n     *  - {@link Errors#FENCED_LEADER_EPOCH}\n     *  - {@link Errors#KAFKA_STORAGE_ERROR}\n     */\n    private final StopReplicaResponseData data;\n\n    public StopReplicaResponse(StopReplicaResponseData data) {\n        super(ApiKeys.STOP_REPLICA);\n        this.data = data;\n    }\n\n    public List<StopReplicaPartitionError> partitionErrors() {\n        return data.partitionErrors();\n    }\n\n    public Errors error() {\n        return Errors.forCode(data.errorCode());\n    }\n\n    @Override\n    public Map<Errors, Integer> errorCounts() {\n        if (data.errorCode() != Errors.NONE.code())\n            // Minor optimization since the top-level error applies to all partitions\n            return Collections.singletonMap(error(), data.partitionErrors().size() + 1);\n        Map<Errors, Integer> errors = errorCounts(data.partitionErrors().stream().map(p -> Errors.forCode(p.errorCode())));\n        updateErrorCounts(errors, Errors.forCode(data.errorCode())); // top level error\n        return errors;\n    }\n\n    public static StopReplicaResponse parse(ByteBuffer buffer, short version) {\n        return new StopReplicaResponse(new StopReplicaResponseData(new ByteBufferAccessor(buffer), version));\n    }\n\n    @Override\n    public int throttleTimeMs() {\n        return DEFAULT_THROTTLE_TIME;\n    }\n\n    @Override\n    public void maybeSetThrottleTimeMs(int throttleTimeMs) {\n        // Not supported by the response schema\n    }\n\n    @Override\n    public StopReplicaResponseData data() {\n        return data;\n    }\n\n    @Override\n    public String toString() {\n        return data.toString();\n    }\n\n}\n",
      "before/clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic abstract class AbstractResponse implements AbstractRequestResponse {\n    public static final int DEFAULT_THROTTLE_TIME = 0;\n\n    private final ApiKeys apiKey;\n\n    protected AbstractResponse(ApiKeys apiKey) {\n        this.apiKey = apiKey;\n    }\n\n    public final Send toSend(ResponseHeader header, short version) {\n        return SendBuilder.buildResponseSend(header, data(), version);\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    final ByteBuffer serializeWithHeader(ResponseHeader header, short version) {\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    final ByteBuffer serialize(short version) {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    /**\n     * The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as\n     * more specifically scoped errors (such as topic or partition-level errors).\n     * @return A count of errors.\n     */\n    public abstract Map<Errors, Integer> errorCounts();\n\n    protected Map<Errors, Integer> errorCounts(Errors error) {\n        return Collections.singletonMap(error, 1);\n    }\n\n    protected Map<Errors, Integer> errorCounts(Stream<Errors> errors) {\n        return errors.collect(Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1)));\n    }\n\n    protected Map<Errors, Integer> errorCounts(Collection<Errors> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (Errors error : errors)\n            updateErrorCounts(errorCounts, error);\n        return errorCounts;\n    }\n\n    protected Map<Errors, Integer> apiErrorCounts(Map<?, ApiError> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (ApiError apiError : errors.values())\n            updateErrorCounts(errorCounts, apiError.error());\n        return errorCounts;\n    }\n\n    protected void updateErrorCounts(Map<Errors, Integer> errorCounts, Errors error) {\n        Integer count = errorCounts.getOrDefault(error, 0);\n        errorCounts.put(error, count + 1);\n    }\n\n    /**\n     * Parse a response from the provided buffer. The buffer is expected to hold both\n     * the {@link ResponseHeader} as well as the response payload.\n     */\n    public static AbstractResponse parseResponse(ByteBuffer buffer, RequestHeader requestHeader) {\n        ApiKeys apiKey = requestHeader.apiKey();\n        short apiVersion = requestHeader.apiVersion();\n\n        ResponseHeader responseHeader = ResponseHeader.parse(buffer, apiKey.responseHeaderVersion(apiVersion));\n\n        if (requestHeader.correlationId() != responseHeader.correlationId()) {\n            throw new CorrelationIdMismatchException(\"Correlation id for response (\"\n                + responseHeader.correlationId() + \") does not match request (\"\n                + requestHeader.correlationId() + \"), request header: \" + requestHeader,\n                requestHeader.correlationId(), responseHeader.correlationId());\n        }\n\n        return AbstractResponse.parseResponse(apiKey, buffer, apiVersion);\n    }\n\n    public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceResponse.parse(responseBuffer, version);\n            case FETCH:\n                return FetchResponse.parse(responseBuffer, version);\n            case LIST_OFFSETS:\n                return ListOffsetsResponse.parse(responseBuffer, version);\n            case METADATA:\n                return MetadataResponse.parse(responseBuffer, version);\n            case OFFSET_COMMIT:\n                return OffsetCommitResponse.parse(responseBuffer, version);\n            case OFFSET_FETCH:\n                return OffsetFetchResponse.parse(responseBuffer, version);\n            case FIND_COORDINATOR:\n                return FindCoordinatorResponse.parse(responseBuffer, version);\n            case JOIN_GROUP:\n                return JoinGroupResponse.parse(responseBuffer, version);\n            case HEARTBEAT:\n                return HeartbeatResponse.parse(responseBuffer, version);\n            case LEAVE_GROUP:\n                return LeaveGroupResponse.parse(responseBuffer, version);\n            case SYNC_GROUP:\n                return SyncGroupResponse.parse(responseBuffer, version);\n            case STOP_REPLICA:\n                return StopReplicaResponse.parse(responseBuffer, version);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownResponse.parse(responseBuffer, version);\n            case UPDATE_METADATA:\n                return UpdateMetadataResponse.parse(responseBuffer, version);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsResponse.parse(responseBuffer, version);\n            case LIST_GROUPS:\n                return ListGroupsResponse.parse(responseBuffer, version);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeResponse.parse(responseBuffer, version);\n            case API_VERSIONS:\n                return ApiVersionsResponse.parse(responseBuffer, version);\n            case CREATE_TOPICS:\n                return CreateTopicsResponse.parse(responseBuffer, version);\n            case DELETE_TOPICS:\n                return DeleteTopicsResponse.parse(responseBuffer, version);\n            case DELETE_RECORDS:\n                return DeleteRecordsResponse.parse(responseBuffer, version);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdResponse.parse(responseBuffer, version);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\n            case END_TXN:\n                return EndTxnResponse.parse(responseBuffer, version);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\n            case DESCRIBE_ACLS:\n                return DescribeAclsResponse.parse(responseBuffer, version);\n            case CREATE_ACLS:\n                return CreateAclsResponse.parse(responseBuffer, version);\n            case DELETE_ACLS:\n                return DeleteAclsResponse.parse(responseBuffer, version);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsResponse.parse(responseBuffer, version);\n            case ALTER_CONFIGS:\n                return AlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsResponse.parse(responseBuffer, version);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\n            case DELETE_GROUPS:\n                return DeleteGroupsResponse.parse(responseBuffer, version);\n            case ELECT_LEADERS:\n                return ElectLeadersResponse.parse(responseBuffer, version);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case OFFSET_DELETE:\n                return OffsetDeleteResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\n            case VOTE:\n                return VoteResponse.parse(responseBuffer, version);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION:\n                return AlterPartitionResponse.parse(responseBuffer, version);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\n            case ENVELOPE:\n                return EnvelopeResponse.parse(responseBuffer, version);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterResponse.parse(responseBuffer, version);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersResponse.parse(responseBuffer, version);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsResponse.parse(responseBuffer, version);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\n            case PUSH_TELEMETRY:\n                return PushTelemetryResponse.parse(responseBuffer, version);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\n            case SHARE_FETCH:\n                return ShareFetchResponse.parse(responseBuffer, version);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterResponse.parse(responseBuffer, version);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseResponse`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n\n    /**\n     * Returns whether or not client should throttle upon receiving a response of the specified version with a non-zero\n     * throttle time. Client-side throttling is needed when communicating with a newer version of broker which, on\n     * quota violation, sends out responses before throttling.\n     */\n    public boolean shouldClientThrottle(short version) {\n        return false;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    /**\n     * Get the throttle time in milliseconds. If the response schema does not\n     * support this field, then 0 will be returned.\n     */\n    public abstract int throttleTimeMs();\n\n    /**\n     * Set the throttle time in the response if the schema supports it. Otherwise,\n     * this is a no-op.\n     *\n     * @param throttleTimeMs The throttle time in milliseconds\n     */\n    public abstract void maybeSetThrottleTimeMs(int throttleTimeMs);\n\n    public String toString() {\n        return data().toString();\n    }\n}\n"
    }
  },
  "4": {
    "score": 0.7854811728000642,
    "path": "data/CH/kafka/commit_1000/57",
    "files": {
      "kafka_57_ch_antipattern.json": "{\n  \"superClass\": \"org.apache.kafka.common.requests.AbstractResponse\",\n  \"subClass\": \"org.apache.kafka.common.requests.ControlledShutdownResponse\",\n  \"files\": [\n    \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n    \"clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownResponse.java\"\n  ],\n  \"dependencyChain\": [\n    {\n      \"from\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n      \"to\": \"org.apache.kafka.common.requests.ControlledShutdownResponse.parse\",\n      \"relationType\": \"Call\"\n    }\n  ],\n  \"codeSnippets\": [\n    {\n      \"fromFile\": \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n      \"toFile\": \"clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownResponse.java\",\n      \"relationType\": \"Call\",\n      \"parentMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n        \"location\": \"112–300\",\n        \"code\": \"public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\\n        switch (apiKey) {\\n            case PRODUCE:\\n                return ProduceResponse.parse(responseBuffer, version);\\n            case FETCH:\\n                return FetchResponse.parse(responseBuffer, version);\\n            case LIST_OFFSETS:\\n                return ListOffsetsResponse.parse(responseBuffer, version);\\n            case METADATA:\\n                return MetadataResponse.parse(responseBuffer, version);\\n            case OFFSET_COMMIT:\\n                return OffsetCommitResponse.parse(responseBuffer, version);\\n            case OFFSET_FETCH:\\n                return OffsetFetchResponse.parse(responseBuffer, version);\\n            case FIND_COORDINATOR:\\n                return FindCoordinatorResponse.parse(responseBuffer, version);\\n            case JOIN_GROUP:\\n                return JoinGroupResponse.parse(responseBuffer, version);\\n            case HEARTBEAT:\\n                return HeartbeatResponse.parse(responseBuffer, version);\\n            case LEAVE_GROUP:\\n                return LeaveGroupResponse.parse(responseBuffer, version);\\n            case SYNC_GROUP:\\n                return SyncGroupResponse.parse(responseBuffer, version);\\n            case STOP_REPLICA:\\n                return StopReplicaResponse.parse(responseBuffer, version);\\n            case CONTROLLED_SHUTDOWN:\\n                return ControlledShutdownResponse.parse(responseBuffer, version);\\n            case UPDATE_METADATA:\\n                return UpdateMetadataResponse.parse(responseBuffer, version);\\n            case LEADER_AND_ISR:\\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\\n            case DESCRIBE_GROUPS:\\n                return DescribeGroupsResponse.parse(responseBuffer, version);\\n            case LIST_GROUPS:\\n                return ListGroupsResponse.parse(responseBuffer, version);\\n            case SASL_HANDSHAKE:\\n                return SaslHandshakeResponse.parse(responseBuffer, version);\\n            case API_VERSIONS:\\n                return ApiVersionsResponse.parse(responseBuffer, version);\\n            case CREATE_TOPICS:\\n                return CreateTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_TOPICS:\\n                return DeleteTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_RECORDS:\\n                return DeleteRecordsResponse.parse(responseBuffer, version);\\n            case INIT_PRODUCER_ID:\\n                return InitProducerIdResponse.parse(responseBuffer, version);\\n            case OFFSET_FOR_LEADER_EPOCH:\\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\\n            case ADD_PARTITIONS_TO_TXN:\\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\\n            case ADD_OFFSETS_TO_TXN:\\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\\n            case END_TXN:\\n                return EndTxnResponse.parse(responseBuffer, version);\\n            case WRITE_TXN_MARKERS:\\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\\n            case TXN_OFFSET_COMMIT:\\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\\n            case DESCRIBE_ACLS:\\n                return DescribeAclsResponse.parse(responseBuffer, version);\\n            case CREATE_ACLS:\\n                return CreateAclsResponse.parse(responseBuffer, version);\\n            case DELETE_ACLS:\\n                return DeleteAclsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CONFIGS:\\n                return DescribeConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_CONFIGS:\\n                return AlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_REPLICA_LOG_DIRS:\\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_LOG_DIRS:\\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\\n            case SASL_AUTHENTICATE:\\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\\n            case CREATE_PARTITIONS:\\n                return CreatePartitionsResponse.parse(responseBuffer, version);\\n            case CREATE_DELEGATION_TOKEN:\\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\\n            case RENEW_DELEGATION_TOKEN:\\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\\n            case EXPIRE_DELEGATION_TOKEN:\\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\\n            case DESCRIBE_DELEGATION_TOKEN:\\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\\n            case DELETE_GROUPS:\\n                return DeleteGroupsResponse.parse(responseBuffer, version);\\n            case ELECT_LEADERS:\\n                return ElectLeadersResponse.parse(responseBuffer, version);\\n            case INCREMENTAL_ALTER_CONFIGS:\\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION_REASSIGNMENTS:\\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case LIST_PARTITION_REASSIGNMENTS:\\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case OFFSET_DELETE:\\n                return OffsetDeleteResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLIENT_QUOTAS:\\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\\n            case ALTER_CLIENT_QUOTAS:\\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case ALTER_USER_SCRAM_CREDENTIALS:\\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case VOTE:\\n                return VoteResponse.parse(responseBuffer, version);\\n            case BEGIN_QUORUM_EPOCH:\\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\\n            case END_QUORUM_EPOCH:\\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\\n            case DESCRIBE_QUORUM:\\n                return DescribeQuorumResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION:\\n                return AlterPartitionResponse.parse(responseBuffer, version);\\n            case UPDATE_FEATURES:\\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\\n            case ENVELOPE:\\n                return EnvelopeResponse.parse(responseBuffer, version);\\n            case FETCH_SNAPSHOT:\\n                return FetchSnapshotResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLUSTER:\\n                return DescribeClusterResponse.parse(responseBuffer, version);\\n            case DESCRIBE_PRODUCERS:\\n                return DescribeProducersResponse.parse(responseBuffer, version);\\n            case BROKER_REGISTRATION:\\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\\n            case BROKER_HEARTBEAT:\\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\\n            case UNREGISTER_BROKER:\\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TRANSACTIONS:\\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\\n            case LIST_TRANSACTIONS:\\n                return ListTransactionsResponse.parse(responseBuffer, version);\\n            case ALLOCATE_PRODUCER_IDS:\\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_HEARTBEAT:\\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_DESCRIBE:\\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\\n            case CONTROLLER_REGISTRATION:\\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\\n            case GET_TELEMETRY_SUBSCRIPTIONS:\\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\\n            case PUSH_TELEMETRY:\\n                return PushTelemetryResponse.parse(responseBuffer, version);\\n            case ASSIGN_REPLICAS_TO_DIRS:\\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\\n            case LIST_CLIENT_METRICS_RESOURCES:\\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TOPIC_PARTITIONS:\\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_HEARTBEAT:\\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_DESCRIBE:\\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\\n            case SHARE_FETCH:\\n                return ShareFetchResponse.parse(responseBuffer, version);\\n            case SHARE_ACKNOWLEDGE:\\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\\n            case ADD_RAFT_VOTER:\\n                return AddRaftVoterResponse.parse(responseBuffer, version);\\n            case REMOVE_RAFT_VOTER:\\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\\n            case UPDATE_RAFT_VOTER:\\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\\n            case INITIALIZE_SHARE_GROUP_STATE:\\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE:\\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\\n            case WRITE_SHARE_GROUP_STATE:\\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\\n            case DELETE_SHARE_GROUP_STATE:\\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE_SUMMARY:\\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_HEARTBEAT:\\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_DESCRIBE:\\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\\n            default:\\n                throw new AssertionError(String.format(\\\"ApiKey %s is not currently handled in `parseResponse`, the \\\" +\\n                        \\\"code should be updated to do so.\\\", apiKey));\\n        }\\n    }\"\n      },\n      \"childMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.ControlledShutdownResponse.parse\",\n        \"location\": \"66–68\",\n        \"code\": \"public static ControlledShutdownResponse parse(ByteBuffer buffer, short version) {\\n        return new ControlledShutdownResponse(new ControlledShutdownResponseData(new ByteBufferAccessor(buffer), version));\\n    }\"\n      },\n      \"invocation\": {\n        \"location\": \"139–139\",\n        \"code\": \"return ControlledShutdownResponse.parse(responseBuffer, version);\"\n      }\n    }\n  ]\n}",
      "before/clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic abstract class AbstractResponse implements AbstractRequestResponse {\n    public static final int DEFAULT_THROTTLE_TIME = 0;\n\n    private final ApiKeys apiKey;\n\n    protected AbstractResponse(ApiKeys apiKey) {\n        this.apiKey = apiKey;\n    }\n\n    public final Send toSend(ResponseHeader header, short version) {\n        return SendBuilder.buildResponseSend(header, data(), version);\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    final ByteBuffer serializeWithHeader(ResponseHeader header, short version) {\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    final ByteBuffer serialize(short version) {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    /**\n     * The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as\n     * more specifically scoped errors (such as topic or partition-level errors).\n     * @return A count of errors.\n     */\n    public abstract Map<Errors, Integer> errorCounts();\n\n    protected Map<Errors, Integer> errorCounts(Errors error) {\n        return Collections.singletonMap(error, 1);\n    }\n\n    protected Map<Errors, Integer> errorCounts(Stream<Errors> errors) {\n        return errors.collect(Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1)));\n    }\n\n    protected Map<Errors, Integer> errorCounts(Collection<Errors> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (Errors error : errors)\n            updateErrorCounts(errorCounts, error);\n        return errorCounts;\n    }\n\n    protected Map<Errors, Integer> apiErrorCounts(Map<?, ApiError> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (ApiError apiError : errors.values())\n            updateErrorCounts(errorCounts, apiError.error());\n        return errorCounts;\n    }\n\n    protected void updateErrorCounts(Map<Errors, Integer> errorCounts, Errors error) {\n        Integer count = errorCounts.getOrDefault(error, 0);\n        errorCounts.put(error, count + 1);\n    }\n\n    /**\n     * Parse a response from the provided buffer. The buffer is expected to hold both\n     * the {@link ResponseHeader} as well as the response payload.\n     */\n    public static AbstractResponse parseResponse(ByteBuffer buffer, RequestHeader requestHeader) {\n        ApiKeys apiKey = requestHeader.apiKey();\n        short apiVersion = requestHeader.apiVersion();\n\n        ResponseHeader responseHeader = ResponseHeader.parse(buffer, apiKey.responseHeaderVersion(apiVersion));\n\n        if (requestHeader.correlationId() != responseHeader.correlationId()) {\n            throw new CorrelationIdMismatchException(\"Correlation id for response (\"\n                + responseHeader.correlationId() + \") does not match request (\"\n                + requestHeader.correlationId() + \"), request header: \" + requestHeader,\n                requestHeader.correlationId(), responseHeader.correlationId());\n        }\n\n        return AbstractResponse.parseResponse(apiKey, buffer, apiVersion);\n    }\n\n    public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceResponse.parse(responseBuffer, version);\n            case FETCH:\n                return FetchResponse.parse(responseBuffer, version);\n            case LIST_OFFSETS:\n                return ListOffsetsResponse.parse(responseBuffer, version);\n            case METADATA:\n                return MetadataResponse.parse(responseBuffer, version);\n            case OFFSET_COMMIT:\n                return OffsetCommitResponse.parse(responseBuffer, version);\n            case OFFSET_FETCH:\n                return OffsetFetchResponse.parse(responseBuffer, version);\n            case FIND_COORDINATOR:\n                return FindCoordinatorResponse.parse(responseBuffer, version);\n            case JOIN_GROUP:\n                return JoinGroupResponse.parse(responseBuffer, version);\n            case HEARTBEAT:\n                return HeartbeatResponse.parse(responseBuffer, version);\n            case LEAVE_GROUP:\n                return LeaveGroupResponse.parse(responseBuffer, version);\n            case SYNC_GROUP:\n                return SyncGroupResponse.parse(responseBuffer, version);\n            case STOP_REPLICA:\n                return StopReplicaResponse.parse(responseBuffer, version);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownResponse.parse(responseBuffer, version);\n            case UPDATE_METADATA:\n                return UpdateMetadataResponse.parse(responseBuffer, version);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsResponse.parse(responseBuffer, version);\n            case LIST_GROUPS:\n                return ListGroupsResponse.parse(responseBuffer, version);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeResponse.parse(responseBuffer, version);\n            case API_VERSIONS:\n                return ApiVersionsResponse.parse(responseBuffer, version);\n            case CREATE_TOPICS:\n                return CreateTopicsResponse.parse(responseBuffer, version);\n            case DELETE_TOPICS:\n                return DeleteTopicsResponse.parse(responseBuffer, version);\n            case DELETE_RECORDS:\n                return DeleteRecordsResponse.parse(responseBuffer, version);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdResponse.parse(responseBuffer, version);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\n            case END_TXN:\n                return EndTxnResponse.parse(responseBuffer, version);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\n            case DESCRIBE_ACLS:\n                return DescribeAclsResponse.parse(responseBuffer, version);\n            case CREATE_ACLS:\n                return CreateAclsResponse.parse(responseBuffer, version);\n            case DELETE_ACLS:\n                return DeleteAclsResponse.parse(responseBuffer, version);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsResponse.parse(responseBuffer, version);\n            case ALTER_CONFIGS:\n                return AlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsResponse.parse(responseBuffer, version);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\n            case DELETE_GROUPS:\n                return DeleteGroupsResponse.parse(responseBuffer, version);\n            case ELECT_LEADERS:\n                return ElectLeadersResponse.parse(responseBuffer, version);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case OFFSET_DELETE:\n                return OffsetDeleteResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\n            case VOTE:\n                return VoteResponse.parse(responseBuffer, version);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION:\n                return AlterPartitionResponse.parse(responseBuffer, version);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\n            case ENVELOPE:\n                return EnvelopeResponse.parse(responseBuffer, version);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterResponse.parse(responseBuffer, version);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersResponse.parse(responseBuffer, version);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsResponse.parse(responseBuffer, version);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\n            case PUSH_TELEMETRY:\n                return PushTelemetryResponse.parse(responseBuffer, version);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\n            case SHARE_FETCH:\n                return ShareFetchResponse.parse(responseBuffer, version);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterResponse.parse(responseBuffer, version);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseResponse`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n\n    /**\n     * Returns whether or not client should throttle upon receiving a response of the specified version with a non-zero\n     * throttle time. Client-side throttling is needed when communicating with a newer version of broker which, on\n     * quota violation, sends out responses before throttling.\n     */\n    public boolean shouldClientThrottle(short version) {\n        return false;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    /**\n     * Get the throttle time in milliseconds. If the response schema does not\n     * support this field, then 0 will be returned.\n     */\n    public abstract int throttleTimeMs();\n\n    /**\n     * Set the throttle time in the response if the schema supports it. Otherwise,\n     * this is a no-op.\n     *\n     * @param throttleTimeMs The throttle time in milliseconds\n     */\n    public abstract void maybeSetThrottleTimeMs(int throttleTimeMs);\n\n    public String toString() {\n        return data().toString();\n    }\n}\n",
      "before/clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.message.ControlledShutdownResponseData;\nimport org.apache.kafka.common.message.ControlledShutdownResponseData.RemainingPartition;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class ControlledShutdownResponse extends AbstractResponse {\n\n    /**\n     * Possible error codes:\n     *\n     * UNKNOWN(-1) (this is because IllegalStateException may be thrown in `KafkaController.shutdownBroker`, it would be good to improve this)\n     * BROKER_NOT_AVAILABLE(8)\n     * STALE_CONTROLLER_EPOCH(11)\n     */\n    private final ControlledShutdownResponseData data;\n\n    public ControlledShutdownResponse(ControlledShutdownResponseData data) {\n        super(ApiKeys.CONTROLLED_SHUTDOWN);\n        this.data = data;\n    }\n\n    public Errors error() {\n        return Errors.forCode(data.errorCode());\n    }\n\n    @Override\n    public Map<Errors, Integer> errorCounts() {\n        return errorCounts(error());\n    }\n\n    @Override\n    public int throttleTimeMs() {\n        return DEFAULT_THROTTLE_TIME;\n    }\n\n    @Override\n    public void maybeSetThrottleTimeMs(int throttleTimeMs) {\n        // Not supported by the response schema\n    }\n\n    public static ControlledShutdownResponse parse(ByteBuffer buffer, short version) {\n        return new ControlledShutdownResponse(new ControlledShutdownResponseData(new ByteBufferAccessor(buffer), version));\n    }\n\n    @Override\n    public ControlledShutdownResponseData data() {\n        return data;\n    }\n\n    public static ControlledShutdownResponse prepareResponse(Errors error, Set<TopicPartition> tps) {\n        ControlledShutdownResponseData data = new ControlledShutdownResponseData();\n        data.setErrorCode(error.code());\n        ControlledShutdownResponseData.RemainingPartitionCollection pSet = new ControlledShutdownResponseData.RemainingPartitionCollection();\n        tps.forEach(tp ->\n            pSet.add(new RemainingPartition()\n                    .setTopicName(tp.topic())\n                    .setPartitionIndex(tp.partition()))\n        );\n        data.setRemainingPartitions(pSet);\n        return new ControlledShutdownResponse(data);\n    }\n\n}\n"
    }
  },
  "5": {
    "score": 0.7752344310283662,
    "path": "data/CH/kafka/commit_1000/91",
    "files": {
      "kafka_91_ch_antipattern.json": "{\n  \"superClass\": \"org.apache.kafka.common.requests.AbstractResponse\",\n  \"subClass\": \"org.apache.kafka.common.requests.ListClientMetricsResourcesResponse\",\n  \"files\": [\n    \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n    \"clients/src/main/java/org/apache/kafka/common/requests/ListClientMetricsResourcesResponse.java\"\n  ],\n  \"dependencyChain\": [\n    {\n      \"from\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n      \"to\": \"org.apache.kafka.common.requests.ListClientMetricsResourcesResponse.parse\",\n      \"relationType\": \"Call\"\n    }\n  ],\n  \"codeSnippets\": [\n    {\n      \"fromFile\": \"clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java\",\n      \"toFile\": \"clients/src/main/java/org/apache/kafka/common/requests/ListClientMetricsResourcesResponse.java\",\n      \"relationType\": \"Call\",\n      \"parentMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.AbstractResponse.parseResponse\",\n        \"location\": \"112–300\",\n        \"code\": \"public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\\n        switch (apiKey) {\\n            case PRODUCE:\\n                return ProduceResponse.parse(responseBuffer, version);\\n            case FETCH:\\n                return FetchResponse.parse(responseBuffer, version);\\n            case LIST_OFFSETS:\\n                return ListOffsetsResponse.parse(responseBuffer, version);\\n            case METADATA:\\n                return MetadataResponse.parse(responseBuffer, version);\\n            case OFFSET_COMMIT:\\n                return OffsetCommitResponse.parse(responseBuffer, version);\\n            case OFFSET_FETCH:\\n                return OffsetFetchResponse.parse(responseBuffer, version);\\n            case FIND_COORDINATOR:\\n                return FindCoordinatorResponse.parse(responseBuffer, version);\\n            case JOIN_GROUP:\\n                return JoinGroupResponse.parse(responseBuffer, version);\\n            case HEARTBEAT:\\n                return HeartbeatResponse.parse(responseBuffer, version);\\n            case LEAVE_GROUP:\\n                return LeaveGroupResponse.parse(responseBuffer, version);\\n            case SYNC_GROUP:\\n                return SyncGroupResponse.parse(responseBuffer, version);\\n            case STOP_REPLICA:\\n                return StopReplicaResponse.parse(responseBuffer, version);\\n            case CONTROLLED_SHUTDOWN:\\n                return ControlledShutdownResponse.parse(responseBuffer, version);\\n            case UPDATE_METADATA:\\n                return UpdateMetadataResponse.parse(responseBuffer, version);\\n            case LEADER_AND_ISR:\\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\\n            case DESCRIBE_GROUPS:\\n                return DescribeGroupsResponse.parse(responseBuffer, version);\\n            case LIST_GROUPS:\\n                return ListGroupsResponse.parse(responseBuffer, version);\\n            case SASL_HANDSHAKE:\\n                return SaslHandshakeResponse.parse(responseBuffer, version);\\n            case API_VERSIONS:\\n                return ApiVersionsResponse.parse(responseBuffer, version);\\n            case CREATE_TOPICS:\\n                return CreateTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_TOPICS:\\n                return DeleteTopicsResponse.parse(responseBuffer, version);\\n            case DELETE_RECORDS:\\n                return DeleteRecordsResponse.parse(responseBuffer, version);\\n            case INIT_PRODUCER_ID:\\n                return InitProducerIdResponse.parse(responseBuffer, version);\\n            case OFFSET_FOR_LEADER_EPOCH:\\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\\n            case ADD_PARTITIONS_TO_TXN:\\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\\n            case ADD_OFFSETS_TO_TXN:\\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\\n            case END_TXN:\\n                return EndTxnResponse.parse(responseBuffer, version);\\n            case WRITE_TXN_MARKERS:\\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\\n            case TXN_OFFSET_COMMIT:\\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\\n            case DESCRIBE_ACLS:\\n                return DescribeAclsResponse.parse(responseBuffer, version);\\n            case CREATE_ACLS:\\n                return CreateAclsResponse.parse(responseBuffer, version);\\n            case DELETE_ACLS:\\n                return DeleteAclsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CONFIGS:\\n                return DescribeConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_CONFIGS:\\n                return AlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_REPLICA_LOG_DIRS:\\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\\n            case DESCRIBE_LOG_DIRS:\\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\\n            case SASL_AUTHENTICATE:\\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\\n            case CREATE_PARTITIONS:\\n                return CreatePartitionsResponse.parse(responseBuffer, version);\\n            case CREATE_DELEGATION_TOKEN:\\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\\n            case RENEW_DELEGATION_TOKEN:\\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\\n            case EXPIRE_DELEGATION_TOKEN:\\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\\n            case DESCRIBE_DELEGATION_TOKEN:\\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\\n            case DELETE_GROUPS:\\n                return DeleteGroupsResponse.parse(responseBuffer, version);\\n            case ELECT_LEADERS:\\n                return ElectLeadersResponse.parse(responseBuffer, version);\\n            case INCREMENTAL_ALTER_CONFIGS:\\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION_REASSIGNMENTS:\\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case LIST_PARTITION_REASSIGNMENTS:\\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\\n            case OFFSET_DELETE:\\n                return OffsetDeleteResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLIENT_QUOTAS:\\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\\n            case ALTER_CLIENT_QUOTAS:\\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case ALTER_USER_SCRAM_CREDENTIALS:\\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\\n            case VOTE:\\n                return VoteResponse.parse(responseBuffer, version);\\n            case BEGIN_QUORUM_EPOCH:\\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\\n            case END_QUORUM_EPOCH:\\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\\n            case DESCRIBE_QUORUM:\\n                return DescribeQuorumResponse.parse(responseBuffer, version);\\n            case ALTER_PARTITION:\\n                return AlterPartitionResponse.parse(responseBuffer, version);\\n            case UPDATE_FEATURES:\\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\\n            case ENVELOPE:\\n                return EnvelopeResponse.parse(responseBuffer, version);\\n            case FETCH_SNAPSHOT:\\n                return FetchSnapshotResponse.parse(responseBuffer, version);\\n            case DESCRIBE_CLUSTER:\\n                return DescribeClusterResponse.parse(responseBuffer, version);\\n            case DESCRIBE_PRODUCERS:\\n                return DescribeProducersResponse.parse(responseBuffer, version);\\n            case BROKER_REGISTRATION:\\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\\n            case BROKER_HEARTBEAT:\\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\\n            case UNREGISTER_BROKER:\\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TRANSACTIONS:\\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\\n            case LIST_TRANSACTIONS:\\n                return ListTransactionsResponse.parse(responseBuffer, version);\\n            case ALLOCATE_PRODUCER_IDS:\\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_HEARTBEAT:\\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case CONSUMER_GROUP_DESCRIBE:\\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\\n            case CONTROLLER_REGISTRATION:\\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\\n            case GET_TELEMETRY_SUBSCRIPTIONS:\\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\\n            case PUSH_TELEMETRY:\\n                return PushTelemetryResponse.parse(responseBuffer, version);\\n            case ASSIGN_REPLICAS_TO_DIRS:\\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\\n            case LIST_CLIENT_METRICS_RESOURCES:\\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\\n            case DESCRIBE_TOPIC_PARTITIONS:\\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_HEARTBEAT:\\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case SHARE_GROUP_DESCRIBE:\\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\\n            case SHARE_FETCH:\\n                return ShareFetchResponse.parse(responseBuffer, version);\\n            case SHARE_ACKNOWLEDGE:\\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\\n            case ADD_RAFT_VOTER:\\n                return AddRaftVoterResponse.parse(responseBuffer, version);\\n            case REMOVE_RAFT_VOTER:\\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\\n            case UPDATE_RAFT_VOTER:\\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\\n            case INITIALIZE_SHARE_GROUP_STATE:\\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE:\\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\\n            case WRITE_SHARE_GROUP_STATE:\\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\\n            case DELETE_SHARE_GROUP_STATE:\\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\\n            case READ_SHARE_GROUP_STATE_SUMMARY:\\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_HEARTBEAT:\\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\\n            case STREAMS_GROUP_DESCRIBE:\\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\\n            default:\\n                throw new AssertionError(String.format(\\\"ApiKey %s is not currently handled in `parseResponse`, the \\\" +\\n                        \\\"code should be updated to do so.\\\", apiKey));\\n        }\\n    }\"\n      },\n      \"childMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.ListClientMetricsResourcesResponse.parse\",\n        \"location\": \"51–54\",\n        \"code\": \"public static ListClientMetricsResourcesResponse parse(ByteBuffer buffer, short version) {\\n        return new ListClientMetricsResourcesResponse(new ListClientMetricsResourcesResponseData(\\n            new ByteBufferAccessor(buffer), version));\\n    }\"\n      },\n      \"invocation\": {\n        \"location\": \"263–263\",\n        \"code\": \"return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\"\n      }\n    }\n  ]\n}",
      "before/clients/src/main/java/org/apache/kafka/common/requests/AbstractResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic abstract class AbstractResponse implements AbstractRequestResponse {\n    public static final int DEFAULT_THROTTLE_TIME = 0;\n\n    private final ApiKeys apiKey;\n\n    protected AbstractResponse(ApiKeys apiKey) {\n        this.apiKey = apiKey;\n    }\n\n    public final Send toSend(ResponseHeader header, short version) {\n        return SendBuilder.buildResponseSend(header, data(), version);\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    final ByteBuffer serializeWithHeader(ResponseHeader header, short version) {\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    final ByteBuffer serialize(short version) {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    /**\n     * The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as\n     * more specifically scoped errors (such as topic or partition-level errors).\n     * @return A count of errors.\n     */\n    public abstract Map<Errors, Integer> errorCounts();\n\n    protected Map<Errors, Integer> errorCounts(Errors error) {\n        return Collections.singletonMap(error, 1);\n    }\n\n    protected Map<Errors, Integer> errorCounts(Stream<Errors> errors) {\n        return errors.collect(Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1)));\n    }\n\n    protected Map<Errors, Integer> errorCounts(Collection<Errors> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (Errors error : errors)\n            updateErrorCounts(errorCounts, error);\n        return errorCounts;\n    }\n\n    protected Map<Errors, Integer> apiErrorCounts(Map<?, ApiError> errors) {\n        Map<Errors, Integer> errorCounts = new HashMap<>();\n        for (ApiError apiError : errors.values())\n            updateErrorCounts(errorCounts, apiError.error());\n        return errorCounts;\n    }\n\n    protected void updateErrorCounts(Map<Errors, Integer> errorCounts, Errors error) {\n        Integer count = errorCounts.getOrDefault(error, 0);\n        errorCounts.put(error, count + 1);\n    }\n\n    /**\n     * Parse a response from the provided buffer. The buffer is expected to hold both\n     * the {@link ResponseHeader} as well as the response payload.\n     */\n    public static AbstractResponse parseResponse(ByteBuffer buffer, RequestHeader requestHeader) {\n        ApiKeys apiKey = requestHeader.apiKey();\n        short apiVersion = requestHeader.apiVersion();\n\n        ResponseHeader responseHeader = ResponseHeader.parse(buffer, apiKey.responseHeaderVersion(apiVersion));\n\n        if (requestHeader.correlationId() != responseHeader.correlationId()) {\n            throw new CorrelationIdMismatchException(\"Correlation id for response (\"\n                + responseHeader.correlationId() + \") does not match request (\"\n                + requestHeader.correlationId() + \"), request header: \" + requestHeader,\n                requestHeader.correlationId(), responseHeader.correlationId());\n        }\n\n        return AbstractResponse.parseResponse(apiKey, buffer, apiVersion);\n    }\n\n    public static AbstractResponse parseResponse(ApiKeys apiKey, ByteBuffer responseBuffer, short version) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceResponse.parse(responseBuffer, version);\n            case FETCH:\n                return FetchResponse.parse(responseBuffer, version);\n            case LIST_OFFSETS:\n                return ListOffsetsResponse.parse(responseBuffer, version);\n            case METADATA:\n                return MetadataResponse.parse(responseBuffer, version);\n            case OFFSET_COMMIT:\n                return OffsetCommitResponse.parse(responseBuffer, version);\n            case OFFSET_FETCH:\n                return OffsetFetchResponse.parse(responseBuffer, version);\n            case FIND_COORDINATOR:\n                return FindCoordinatorResponse.parse(responseBuffer, version);\n            case JOIN_GROUP:\n                return JoinGroupResponse.parse(responseBuffer, version);\n            case HEARTBEAT:\n                return HeartbeatResponse.parse(responseBuffer, version);\n            case LEAVE_GROUP:\n                return LeaveGroupResponse.parse(responseBuffer, version);\n            case SYNC_GROUP:\n                return SyncGroupResponse.parse(responseBuffer, version);\n            case STOP_REPLICA:\n                return StopReplicaResponse.parse(responseBuffer, version);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownResponse.parse(responseBuffer, version);\n            case UPDATE_METADATA:\n                return UpdateMetadataResponse.parse(responseBuffer, version);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrResponse.parse(responseBuffer, version);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsResponse.parse(responseBuffer, version);\n            case LIST_GROUPS:\n                return ListGroupsResponse.parse(responseBuffer, version);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeResponse.parse(responseBuffer, version);\n            case API_VERSIONS:\n                return ApiVersionsResponse.parse(responseBuffer, version);\n            case CREATE_TOPICS:\n                return CreateTopicsResponse.parse(responseBuffer, version);\n            case DELETE_TOPICS:\n                return DeleteTopicsResponse.parse(responseBuffer, version);\n            case DELETE_RECORDS:\n                return DeleteRecordsResponse.parse(responseBuffer, version);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdResponse.parse(responseBuffer, version);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochResponse.parse(responseBuffer, version);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnResponse.parse(responseBuffer, version);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnResponse.parse(responseBuffer, version);\n            case END_TXN:\n                return EndTxnResponse.parse(responseBuffer, version);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersResponse.parse(responseBuffer, version);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitResponse.parse(responseBuffer, version);\n            case DESCRIBE_ACLS:\n                return DescribeAclsResponse.parse(responseBuffer, version);\n            case CREATE_ACLS:\n                return CreateAclsResponse.parse(responseBuffer, version);\n            case DELETE_ACLS:\n                return DeleteAclsResponse.parse(responseBuffer, version);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsResponse.parse(responseBuffer, version);\n            case ALTER_CONFIGS:\n                return AlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsResponse.parse(responseBuffer, version);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsResponse.parse(responseBuffer, version);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateResponse.parse(responseBuffer, version);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsResponse.parse(responseBuffer, version);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenResponse.parse(responseBuffer, version);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenResponse.parse(responseBuffer, version);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenResponse.parse(responseBuffer, version);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenResponse.parse(responseBuffer, version);\n            case DELETE_GROUPS:\n                return DeleteGroupsResponse.parse(responseBuffer, version);\n            case ELECT_LEADERS:\n                return ElectLeadersResponse.parse(responseBuffer, version);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsResponse.parse(responseBuffer, version);\n            case OFFSET_DELETE:\n                return OffsetDeleteResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasResponse.parse(responseBuffer, version);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasResponse.parse(responseBuffer, version);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsResponse.parse(responseBuffer, version);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsResponse.parse(responseBuffer, version);\n            case VOTE:\n                return VoteResponse.parse(responseBuffer, version);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochResponse.parse(responseBuffer, version);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochResponse.parse(responseBuffer, version);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumResponse.parse(responseBuffer, version);\n            case ALTER_PARTITION:\n                return AlterPartitionResponse.parse(responseBuffer, version);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesResponse.parse(responseBuffer, version);\n            case ENVELOPE:\n                return EnvelopeResponse.parse(responseBuffer, version);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotResponse.parse(responseBuffer, version);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterResponse.parse(responseBuffer, version);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersResponse.parse(responseBuffer, version);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationResponse.parse(responseBuffer, version);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatResponse.parse(responseBuffer, version);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerResponse.parse(responseBuffer, version);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsResponse.parse(responseBuffer, version);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsResponse.parse(responseBuffer, version);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatResponse.parse(responseBuffer, version);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeResponse.parse(responseBuffer, version);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationResponse.parse(responseBuffer, version);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsResponse.parse(responseBuffer, version);\n            case PUSH_TELEMETRY:\n                return PushTelemetryResponse.parse(responseBuffer, version);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsResponse.parse(responseBuffer, version);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesResponse.parse(responseBuffer, version);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatResponse.parse(responseBuffer, version);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeResponse.parse(responseBuffer, version);\n            case SHARE_FETCH:\n                return ShareFetchResponse.parse(responseBuffer, version);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeResponse.parse(responseBuffer, version);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterResponse.parse(responseBuffer, version);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterResponse.parse(responseBuffer, version);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterResponse.parse(responseBuffer, version);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateResponse.parse(responseBuffer, version);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateResponse.parse(responseBuffer, version);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateResponse.parse(responseBuffer, version);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatResponse.parse(responseBuffer, version);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeResponse.parse(responseBuffer, version);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsResponse.parse(responseBuffer, version);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseResponse`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n\n    /**\n     * Returns whether or not client should throttle upon receiving a response of the specified version with a non-zero\n     * throttle time. Client-side throttling is needed when communicating with a newer version of broker which, on\n     * quota violation, sends out responses before throttling.\n     */\n    public boolean shouldClientThrottle(short version) {\n        return false;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    /**\n     * Get the throttle time in milliseconds. If the response schema does not\n     * support this field, then 0 will be returned.\n     */\n    public abstract int throttleTimeMs();\n\n    /**\n     * Set the throttle time in the response if the schema supports it. Otherwise,\n     * this is a no-op.\n     *\n     * @param throttleTimeMs The throttle time in milliseconds\n     */\n    public abstract void maybeSetThrottleTimeMs(int throttleTimeMs);\n\n    public String toString() {\n        return data().toString();\n    }\n}\n",
      "before/clients/src/main/java/org/apache/kafka/common/requests/ListClientMetricsResourcesResponse.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.clients.admin.ClientMetricsResourceListing;\nimport org.apache.kafka.common.message.ListClientMetricsResourcesResponseData;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class ListClientMetricsResourcesResponse extends AbstractResponse {\n    private final ListClientMetricsResourcesResponseData data;\n\n    public ListClientMetricsResourcesResponse(ListClientMetricsResourcesResponseData data) {\n        super(ApiKeys.LIST_CLIENT_METRICS_RESOURCES);\n        this.data = data;\n    }\n\n    public ListClientMetricsResourcesResponseData data() {\n        return data;\n    }\n\n    public ApiError error() {\n        return new ApiError(Errors.forCode(data.errorCode()));\n    }\n\n    @Override\n    public Map<Errors, Integer> errorCounts() {\n        return errorCounts(Errors.forCode(data.errorCode()));\n    }\n\n    public static ListClientMetricsResourcesResponse parse(ByteBuffer buffer, short version) {\n        return new ListClientMetricsResourcesResponse(new ListClientMetricsResourcesResponseData(\n            new ByteBufferAccessor(buffer), version));\n    }\n\n    @Override\n    public String toString() {\n        return data.toString();\n    }\n\n    @Override\n    public int throttleTimeMs() {\n        return data.throttleTimeMs();\n    }\n\n    @Override\n    public void maybeSetThrottleTimeMs(int throttleTimeMs) {\n        data.setThrottleTimeMs(throttleTimeMs);\n    }\n\n    public Collection<ClientMetricsResourceListing> clientMetricsResources() {\n        return data.clientMetricsResources()\n            .stream()\n            .map(entry -> new ClientMetricsResourceListing(entry.name()))\n            .collect(Collectors.toList());\n    }\n}\n"
    }
  },
  "6": {
    "score": 0.7534644186496734,
    "path": "data/CH/kafka/commit_1000/158",
    "files": {
      "kafka_158_ch_antipattern.json": "{\n  \"superClass\": \"org.apache.kafka.common.requests.AbstractRequest\",\n  \"subClass\": \"org.apache.kafka.common.requests.ControlledShutdownRequest\",\n  \"files\": [\n    \"clients/src/main/java/org/apache/kafka/common/requests/AbstractRequest.java\",\n    \"clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownRequest.java\"\n  ],\n  \"dependencyChain\": [\n    {\n      \"from\": \"org.apache.kafka.common.requests.AbstractRequest.doParseRequest\",\n      \"to\": \"org.apache.kafka.common.requests.ControlledShutdownRequest.parse\",\n      \"relationType\": \"Call\"\n    }\n  ],\n  \"codeSnippets\": [\n    {\n      \"fromFile\": \"clients/src/main/java/org/apache/kafka/common/requests/AbstractRequest.java\",\n      \"toFile\": \"clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownRequest.java\",\n      \"relationType\": \"Call\",\n      \"parentMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.AbstractRequest.doParseRequest\",\n        \"location\": \"175–363\",\n        \"code\": \"private static AbstractRequest doParseRequest(ApiKeys apiKey, short apiVersion, ByteBuffer buffer) {\\n        switch (apiKey) {\\n            case PRODUCE:\\n                return ProduceRequest.parse(buffer, apiVersion);\\n            case FETCH:\\n                return FetchRequest.parse(buffer, apiVersion);\\n            case LIST_OFFSETS:\\n                return ListOffsetsRequest.parse(buffer, apiVersion);\\n            case METADATA:\\n                return MetadataRequest.parse(buffer, apiVersion);\\n            case OFFSET_COMMIT:\\n                return OffsetCommitRequest.parse(buffer, apiVersion);\\n            case OFFSET_FETCH:\\n                return OffsetFetchRequest.parse(buffer, apiVersion);\\n            case FIND_COORDINATOR:\\n                return FindCoordinatorRequest.parse(buffer, apiVersion);\\n            case JOIN_GROUP:\\n                return JoinGroupRequest.parse(buffer, apiVersion);\\n            case HEARTBEAT:\\n                return HeartbeatRequest.parse(buffer, apiVersion);\\n            case LEAVE_GROUP:\\n                return LeaveGroupRequest.parse(buffer, apiVersion);\\n            case SYNC_GROUP:\\n                return SyncGroupRequest.parse(buffer, apiVersion);\\n            case STOP_REPLICA:\\n                return StopReplicaRequest.parse(buffer, apiVersion);\\n            case CONTROLLED_SHUTDOWN:\\n                return ControlledShutdownRequest.parse(buffer, apiVersion);\\n            case UPDATE_METADATA:\\n                return UpdateMetadataRequest.parse(buffer, apiVersion);\\n            case LEADER_AND_ISR:\\n                return LeaderAndIsrRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_GROUPS:\\n                return DescribeGroupsRequest.parse(buffer, apiVersion);\\n            case LIST_GROUPS:\\n                return ListGroupsRequest.parse(buffer, apiVersion);\\n            case SASL_HANDSHAKE:\\n                return SaslHandshakeRequest.parse(buffer, apiVersion);\\n            case API_VERSIONS:\\n                return ApiVersionsRequest.parse(buffer, apiVersion);\\n            case CREATE_TOPICS:\\n                return CreateTopicsRequest.parse(buffer, apiVersion);\\n            case DELETE_TOPICS:\\n                return DeleteTopicsRequest.parse(buffer, apiVersion);\\n            case DELETE_RECORDS:\\n                return DeleteRecordsRequest.parse(buffer, apiVersion);\\n            case INIT_PRODUCER_ID:\\n                return InitProducerIdRequest.parse(buffer, apiVersion);\\n            case OFFSET_FOR_LEADER_EPOCH:\\n                return OffsetsForLeaderEpochRequest.parse(buffer, apiVersion);\\n            case ADD_PARTITIONS_TO_TXN:\\n                return AddPartitionsToTxnRequest.parse(buffer, apiVersion);\\n            case ADD_OFFSETS_TO_TXN:\\n                return AddOffsetsToTxnRequest.parse(buffer, apiVersion);\\n            case END_TXN:\\n                return EndTxnRequest.parse(buffer, apiVersion);\\n            case WRITE_TXN_MARKERS:\\n                return WriteTxnMarkersRequest.parse(buffer, apiVersion);\\n            case TXN_OFFSET_COMMIT:\\n                return TxnOffsetCommitRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_ACLS:\\n                return DescribeAclsRequest.parse(buffer, apiVersion);\\n            case CREATE_ACLS:\\n                return CreateAclsRequest.parse(buffer, apiVersion);\\n            case DELETE_ACLS:\\n                return DeleteAclsRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_CONFIGS:\\n                return DescribeConfigsRequest.parse(buffer, apiVersion);\\n            case ALTER_CONFIGS:\\n                return AlterConfigsRequest.parse(buffer, apiVersion);\\n            case ALTER_REPLICA_LOG_DIRS:\\n                return AlterReplicaLogDirsRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_LOG_DIRS:\\n                return DescribeLogDirsRequest.parse(buffer, apiVersion);\\n            case SASL_AUTHENTICATE:\\n                return SaslAuthenticateRequest.parse(buffer, apiVersion);\\n            case CREATE_PARTITIONS:\\n                return CreatePartitionsRequest.parse(buffer, apiVersion);\\n            case CREATE_DELEGATION_TOKEN:\\n                return CreateDelegationTokenRequest.parse(buffer, apiVersion);\\n            case RENEW_DELEGATION_TOKEN:\\n                return RenewDelegationTokenRequest.parse(buffer, apiVersion);\\n            case EXPIRE_DELEGATION_TOKEN:\\n                return ExpireDelegationTokenRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_DELEGATION_TOKEN:\\n                return DescribeDelegationTokenRequest.parse(buffer, apiVersion);\\n            case DELETE_GROUPS:\\n                return DeleteGroupsRequest.parse(buffer, apiVersion);\\n            case ELECT_LEADERS:\\n                return ElectLeadersRequest.parse(buffer, apiVersion);\\n            case INCREMENTAL_ALTER_CONFIGS:\\n                return IncrementalAlterConfigsRequest.parse(buffer, apiVersion);\\n            case ALTER_PARTITION_REASSIGNMENTS:\\n                return AlterPartitionReassignmentsRequest.parse(buffer, apiVersion);\\n            case LIST_PARTITION_REASSIGNMENTS:\\n                return ListPartitionReassignmentsRequest.parse(buffer, apiVersion);\\n            case OFFSET_DELETE:\\n                return OffsetDeleteRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_CLIENT_QUOTAS:\\n                return DescribeClientQuotasRequest.parse(buffer, apiVersion);\\n            case ALTER_CLIENT_QUOTAS:\\n                return AlterClientQuotasRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\\n                return DescribeUserScramCredentialsRequest.parse(buffer, apiVersion);\\n            case ALTER_USER_SCRAM_CREDENTIALS:\\n                return AlterUserScramCredentialsRequest.parse(buffer, apiVersion);\\n            case VOTE:\\n                return VoteRequest.parse(buffer, apiVersion);\\n            case BEGIN_QUORUM_EPOCH:\\n                return BeginQuorumEpochRequest.parse(buffer, apiVersion);\\n            case END_QUORUM_EPOCH:\\n                return EndQuorumEpochRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_QUORUM:\\n                return DescribeQuorumRequest.parse(buffer, apiVersion);\\n            case ALTER_PARTITION:\\n                return AlterPartitionRequest.parse(buffer, apiVersion);\\n            case UPDATE_FEATURES:\\n                return UpdateFeaturesRequest.parse(buffer, apiVersion);\\n            case ENVELOPE:\\n                return EnvelopeRequest.parse(buffer, apiVersion);\\n            case FETCH_SNAPSHOT:\\n                return FetchSnapshotRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_CLUSTER:\\n                return DescribeClusterRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_PRODUCERS:\\n                return DescribeProducersRequest.parse(buffer, apiVersion);\\n            case BROKER_REGISTRATION:\\n                return BrokerRegistrationRequest.parse(buffer, apiVersion);\\n            case BROKER_HEARTBEAT:\\n                return BrokerHeartbeatRequest.parse(buffer, apiVersion);\\n            case UNREGISTER_BROKER:\\n                return UnregisterBrokerRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_TRANSACTIONS:\\n                return DescribeTransactionsRequest.parse(buffer, apiVersion);\\n            case LIST_TRANSACTIONS:\\n                return ListTransactionsRequest.parse(buffer, apiVersion);\\n            case ALLOCATE_PRODUCER_IDS:\\n                return AllocateProducerIdsRequest.parse(buffer, apiVersion);\\n            case CONSUMER_GROUP_HEARTBEAT:\\n                return ConsumerGroupHeartbeatRequest.parse(buffer, apiVersion);\\n            case CONSUMER_GROUP_DESCRIBE:\\n                return ConsumerGroupDescribeRequest.parse(buffer, apiVersion);\\n            case CONTROLLER_REGISTRATION:\\n                return ControllerRegistrationRequest.parse(buffer, apiVersion);\\n            case GET_TELEMETRY_SUBSCRIPTIONS:\\n                return GetTelemetrySubscriptionsRequest.parse(buffer, apiVersion);\\n            case PUSH_TELEMETRY:\\n                return PushTelemetryRequest.parse(buffer, apiVersion);\\n            case ASSIGN_REPLICAS_TO_DIRS:\\n                return AssignReplicasToDirsRequest.parse(buffer, apiVersion);\\n            case LIST_CLIENT_METRICS_RESOURCES:\\n                return ListClientMetricsResourcesRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_TOPIC_PARTITIONS:\\n                return DescribeTopicPartitionsRequest.parse(buffer, apiVersion);\\n            case SHARE_GROUP_HEARTBEAT:\\n                return ShareGroupHeartbeatRequest.parse(buffer, apiVersion);\\n            case SHARE_GROUP_DESCRIBE:\\n                return ShareGroupDescribeRequest.parse(buffer, apiVersion);\\n            case SHARE_FETCH:\\n                return ShareFetchRequest.parse(buffer, apiVersion);\\n            case SHARE_ACKNOWLEDGE:\\n                return ShareAcknowledgeRequest.parse(buffer, apiVersion);\\n            case ADD_RAFT_VOTER:\\n                return AddRaftVoterRequest.parse(buffer, apiVersion);\\n            case REMOVE_RAFT_VOTER:\\n                return RemoveRaftVoterRequest.parse(buffer, apiVersion);\\n            case UPDATE_RAFT_VOTER:\\n                return UpdateRaftVoterRequest.parse(buffer, apiVersion);\\n            case INITIALIZE_SHARE_GROUP_STATE:\\n                return InitializeShareGroupStateRequest.parse(buffer, apiVersion);\\n            case READ_SHARE_GROUP_STATE:\\n                return ReadShareGroupStateRequest.parse(buffer, apiVersion);\\n            case WRITE_SHARE_GROUP_STATE:\\n                return WriteShareGroupStateRequest.parse(buffer, apiVersion);\\n            case DELETE_SHARE_GROUP_STATE:\\n                return DeleteShareGroupStateRequest.parse(buffer, apiVersion);\\n            case READ_SHARE_GROUP_STATE_SUMMARY:\\n                return ReadShareGroupStateSummaryRequest.parse(buffer, apiVersion);\\n            case STREAMS_GROUP_HEARTBEAT:\\n                return StreamsGroupHeartbeatRequest.parse(buffer, apiVersion);\\n            case STREAMS_GROUP_DESCRIBE:\\n                return StreamsGroupDescribeRequest.parse(buffer, apiVersion);\\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\\n                return DescribeShareGroupOffsetsRequest.parse(buffer, apiVersion);\\n            default:\\n                throw new AssertionError(String.format(\\\"ApiKey %s is not currently handled in `parseRequest`, the \\\" +\\n                        \\\"code should be updated to do so.\\\", apiKey));\\n        }\\n    }\"\n      },\n      \"childMethod\": {\n        \"entity\": \"org.apache.kafka.common.requests.ControlledShutdownRequest.parse\",\n        \"location\": \"63–66\",\n        \"code\": \"public static ControlledShutdownRequest parse(ByteBuffer buffer, short version) {\\n        return new ControlledShutdownRequest(new ControlledShutdownRequestData(new ByteBufferAccessor(buffer), version),\\n            version);\\n    }\"\n      },\n      \"invocation\": {\n        \"location\": \"202–202\",\n        \"code\": \"return ControlledShutdownRequest.parse(buffer, apiVersion);\"\n      }\n    }\n  ]\n}",
      "before/clients/src/main/java/org/apache/kafka/common/requests/ControlledShutdownRequest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.message.ControlledShutdownRequestData;\nimport org.apache.kafka.common.message.ControlledShutdownResponseData;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.ByteBufferAccessor;\nimport org.apache.kafka.common.protocol.Errors;\n\nimport java.nio.ByteBuffer;\n\npublic class ControlledShutdownRequest extends AbstractRequest {\n\n    public static class Builder extends AbstractRequest.Builder<ControlledShutdownRequest> {\n\n        private final ControlledShutdownRequestData data;\n\n        public Builder(ControlledShutdownRequestData data, short desiredVersion) {\n            super(ApiKeys.CONTROLLED_SHUTDOWN, desiredVersion);\n            this.data = data;\n        }\n\n        @Override\n        public ControlledShutdownRequest build(short version) {\n            return new ControlledShutdownRequest(data, version);\n        }\n\n        @Override\n        public String toString() {\n            return data.toString();\n        }\n    }\n\n    private final ControlledShutdownRequestData data;\n\n    private ControlledShutdownRequest(ControlledShutdownRequestData data, short version) {\n        super(ApiKeys.CONTROLLED_SHUTDOWN, version);\n        this.data = data;\n    }\n\n    @Override\n    public ControlledShutdownResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n        ControlledShutdownResponseData data = new ControlledShutdownResponseData()\n                .setErrorCode(Errors.forException(e).code());\n        return new ControlledShutdownResponse(data);\n    }\n\n    public static ControlledShutdownRequest parse(ByteBuffer buffer, short version) {\n        return new ControlledShutdownRequest(new ControlledShutdownRequestData(new ByteBufferAccessor(buffer), version),\n            version);\n    }\n\n    @Override\n    public ControlledShutdownRequestData data() {\n        return data;\n    }\n}\n",
      "before/clients/src/main/java/org/apache/kafka/common/requests/AbstractRequest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.requests;\n\nimport org.apache.kafka.common.errors.UnsupportedVersionException;\nimport org.apache.kafka.common.network.Send;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.protocol.MessageUtil;\nimport org.apache.kafka.common.protocol.ObjectSerializationCache;\nimport org.apache.kafka.common.protocol.SendBuilder;\n\nimport java.nio.ByteBuffer;\nimport java.util.Map;\n\npublic abstract class AbstractRequest implements AbstractRequestResponse {\n\n    public abstract static class Builder<T extends AbstractRequest> {\n        private final ApiKeys apiKey;\n        private final short oldestAllowedVersion;\n        private final short latestAllowedVersion;\n\n        /**\n         * Construct a new builder which allows any supported version\n         */\n        public Builder(ApiKeys apiKey, boolean enableUnstableLastVersion) {\n            this(apiKey, apiKey.oldestVersion(), apiKey.latestVersion(enableUnstableLastVersion));\n        }\n\n        /**\n         * Construct a new builder which allows any supported and released version\n         */\n        public Builder(ApiKeys apiKey) {\n            this(apiKey, false);\n        }\n\n        /**\n         * Construct a new builder which allows only a specific version\n         */\n        public Builder(ApiKeys apiKey, short allowedVersion) {\n            this(apiKey, allowedVersion, allowedVersion);\n        }\n\n        /**\n         * Construct a new builder which allows an inclusive range of versions\n         */\n        public Builder(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {\n            this.apiKey = apiKey;\n            this.oldestAllowedVersion = oldestAllowedVersion;\n            this.latestAllowedVersion = latestAllowedVersion;\n        }\n\n        public ApiKeys apiKey() {\n            return apiKey;\n        }\n\n        public short oldestAllowedVersion() {\n            return oldestAllowedVersion;\n        }\n\n        public short latestAllowedVersion() {\n            return latestAllowedVersion;\n        }\n\n        public T build() {\n            return build(latestAllowedVersion());\n        }\n\n        public abstract T build(short version);\n    }\n\n    private final short version;\n    private final ApiKeys apiKey;\n\n    public AbstractRequest(ApiKeys apiKey, short version) {\n        if (!apiKey.isVersionSupported(version))\n            throw new UnsupportedVersionException(\"The \" + apiKey + \" protocol does not support version \" + version);\n        this.version = version;\n        this.apiKey = apiKey;\n    }\n\n    /**\n     * Get the version of this AbstractRequest object.\n     */\n    public short version() {\n        return version;\n    }\n\n    public ApiKeys apiKey() {\n        return apiKey;\n    }\n\n    public final Send toSend(RequestHeader header) {\n        return SendBuilder.buildRequestSend(header, data());\n    }\n\n    /**\n     * Serializes header and body without prefixing with size (unlike `toSend`, which does include a size prefix).\n     */\n    public final ByteBuffer serializeWithHeader(RequestHeader header) {\n        if (header.apiKey() != apiKey) {\n            throw new IllegalArgumentException(\"Could not build request \" + apiKey + \" with header api key \" + header.apiKey());\n        }\n        if (header.apiVersion() != version) {\n            throw new IllegalArgumentException(\"Could not build request version \" + version + \" with header version \" + header.apiVersion());\n        }\n        return RequestUtils.serialize(header.data(), header.headerVersion(), data(), version);\n    }\n\n    // Visible for testing\n    public final ByteBuffer serialize() {\n        return MessageUtil.toByteBuffer(data(), version);\n    }\n\n    // Visible for testing\n    final int sizeInBytes() {\n        return data().size(new ObjectSerializationCache(), version);\n    }\n\n    public String toString(boolean verbose) {\n        return data().toString();\n    }\n\n    @Override\n    public final String toString() {\n        return toString(true);\n    }\n\n    /**\n     * Get an error response for a request\n     */\n    public AbstractResponse getErrorResponse(Throwable e) {\n        return getErrorResponse(AbstractResponse.DEFAULT_THROTTLE_TIME, e);\n    }\n\n    /**\n     * Get an error response for a request with specified throttle time in the response if applicable\n     */\n    public abstract AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e);\n\n    /**\n     * Get the error counts corresponding to an error response. This is overridden for requests\n     * where response may be null (e.g produce with acks=0).\n     */\n    public Map<Errors, Integer> errorCounts(Throwable e) {\n        AbstractResponse response = getErrorResponse(0, e);\n        if (response == null)\n            throw new IllegalStateException(\"Error counts could not be obtained for request \" + this);\n        else\n            return response.errorCounts();\n    }\n\n    /**\n     * Factory method for getting a request object based on ApiKey ID and a version\n     */\n    public static RequestAndSize parseRequest(ApiKeys apiKey, short apiVersion, ByteBuffer buffer) {\n        int bufferSize = buffer.remaining();\n        return new RequestAndSize(doParseRequest(apiKey, apiVersion, buffer), bufferSize);\n    }\n\n    private static AbstractRequest doParseRequest(ApiKeys apiKey, short apiVersion, ByteBuffer buffer) {\n        switch (apiKey) {\n            case PRODUCE:\n                return ProduceRequest.parse(buffer, apiVersion);\n            case FETCH:\n                return FetchRequest.parse(buffer, apiVersion);\n            case LIST_OFFSETS:\n                return ListOffsetsRequest.parse(buffer, apiVersion);\n            case METADATA:\n                return MetadataRequest.parse(buffer, apiVersion);\n            case OFFSET_COMMIT:\n                return OffsetCommitRequest.parse(buffer, apiVersion);\n            case OFFSET_FETCH:\n                return OffsetFetchRequest.parse(buffer, apiVersion);\n            case FIND_COORDINATOR:\n                return FindCoordinatorRequest.parse(buffer, apiVersion);\n            case JOIN_GROUP:\n                return JoinGroupRequest.parse(buffer, apiVersion);\n            case HEARTBEAT:\n                return HeartbeatRequest.parse(buffer, apiVersion);\n            case LEAVE_GROUP:\n                return LeaveGroupRequest.parse(buffer, apiVersion);\n            case SYNC_GROUP:\n                return SyncGroupRequest.parse(buffer, apiVersion);\n            case STOP_REPLICA:\n                return StopReplicaRequest.parse(buffer, apiVersion);\n            case CONTROLLED_SHUTDOWN:\n                return ControlledShutdownRequest.parse(buffer, apiVersion);\n            case UPDATE_METADATA:\n                return UpdateMetadataRequest.parse(buffer, apiVersion);\n            case LEADER_AND_ISR:\n                return LeaderAndIsrRequest.parse(buffer, apiVersion);\n            case DESCRIBE_GROUPS:\n                return DescribeGroupsRequest.parse(buffer, apiVersion);\n            case LIST_GROUPS:\n                return ListGroupsRequest.parse(buffer, apiVersion);\n            case SASL_HANDSHAKE:\n                return SaslHandshakeRequest.parse(buffer, apiVersion);\n            case API_VERSIONS:\n                return ApiVersionsRequest.parse(buffer, apiVersion);\n            case CREATE_TOPICS:\n                return CreateTopicsRequest.parse(buffer, apiVersion);\n            case DELETE_TOPICS:\n                return DeleteTopicsRequest.parse(buffer, apiVersion);\n            case DELETE_RECORDS:\n                return DeleteRecordsRequest.parse(buffer, apiVersion);\n            case INIT_PRODUCER_ID:\n                return InitProducerIdRequest.parse(buffer, apiVersion);\n            case OFFSET_FOR_LEADER_EPOCH:\n                return OffsetsForLeaderEpochRequest.parse(buffer, apiVersion);\n            case ADD_PARTITIONS_TO_TXN:\n                return AddPartitionsToTxnRequest.parse(buffer, apiVersion);\n            case ADD_OFFSETS_TO_TXN:\n                return AddOffsetsToTxnRequest.parse(buffer, apiVersion);\n            case END_TXN:\n                return EndTxnRequest.parse(buffer, apiVersion);\n            case WRITE_TXN_MARKERS:\n                return WriteTxnMarkersRequest.parse(buffer, apiVersion);\n            case TXN_OFFSET_COMMIT:\n                return TxnOffsetCommitRequest.parse(buffer, apiVersion);\n            case DESCRIBE_ACLS:\n                return DescribeAclsRequest.parse(buffer, apiVersion);\n            case CREATE_ACLS:\n                return CreateAclsRequest.parse(buffer, apiVersion);\n            case DELETE_ACLS:\n                return DeleteAclsRequest.parse(buffer, apiVersion);\n            case DESCRIBE_CONFIGS:\n                return DescribeConfigsRequest.parse(buffer, apiVersion);\n            case ALTER_CONFIGS:\n                return AlterConfigsRequest.parse(buffer, apiVersion);\n            case ALTER_REPLICA_LOG_DIRS:\n                return AlterReplicaLogDirsRequest.parse(buffer, apiVersion);\n            case DESCRIBE_LOG_DIRS:\n                return DescribeLogDirsRequest.parse(buffer, apiVersion);\n            case SASL_AUTHENTICATE:\n                return SaslAuthenticateRequest.parse(buffer, apiVersion);\n            case CREATE_PARTITIONS:\n                return CreatePartitionsRequest.parse(buffer, apiVersion);\n            case CREATE_DELEGATION_TOKEN:\n                return CreateDelegationTokenRequest.parse(buffer, apiVersion);\n            case RENEW_DELEGATION_TOKEN:\n                return RenewDelegationTokenRequest.parse(buffer, apiVersion);\n            case EXPIRE_DELEGATION_TOKEN:\n                return ExpireDelegationTokenRequest.parse(buffer, apiVersion);\n            case DESCRIBE_DELEGATION_TOKEN:\n                return DescribeDelegationTokenRequest.parse(buffer, apiVersion);\n            case DELETE_GROUPS:\n                return DeleteGroupsRequest.parse(buffer, apiVersion);\n            case ELECT_LEADERS:\n                return ElectLeadersRequest.parse(buffer, apiVersion);\n            case INCREMENTAL_ALTER_CONFIGS:\n                return IncrementalAlterConfigsRequest.parse(buffer, apiVersion);\n            case ALTER_PARTITION_REASSIGNMENTS:\n                return AlterPartitionReassignmentsRequest.parse(buffer, apiVersion);\n            case LIST_PARTITION_REASSIGNMENTS:\n                return ListPartitionReassignmentsRequest.parse(buffer, apiVersion);\n            case OFFSET_DELETE:\n                return OffsetDeleteRequest.parse(buffer, apiVersion);\n            case DESCRIBE_CLIENT_QUOTAS:\n                return DescribeClientQuotasRequest.parse(buffer, apiVersion);\n            case ALTER_CLIENT_QUOTAS:\n                return AlterClientQuotasRequest.parse(buffer, apiVersion);\n            case DESCRIBE_USER_SCRAM_CREDENTIALS:\n                return DescribeUserScramCredentialsRequest.parse(buffer, apiVersion);\n            case ALTER_USER_SCRAM_CREDENTIALS:\n                return AlterUserScramCredentialsRequest.parse(buffer, apiVersion);\n            case VOTE:\n                return VoteRequest.parse(buffer, apiVersion);\n            case BEGIN_QUORUM_EPOCH:\n                return BeginQuorumEpochRequest.parse(buffer, apiVersion);\n            case END_QUORUM_EPOCH:\n                return EndQuorumEpochRequest.parse(buffer, apiVersion);\n            case DESCRIBE_QUORUM:\n                return DescribeQuorumRequest.parse(buffer, apiVersion);\n            case ALTER_PARTITION:\n                return AlterPartitionRequest.parse(buffer, apiVersion);\n            case UPDATE_FEATURES:\n                return UpdateFeaturesRequest.parse(buffer, apiVersion);\n            case ENVELOPE:\n                return EnvelopeRequest.parse(buffer, apiVersion);\n            case FETCH_SNAPSHOT:\n                return FetchSnapshotRequest.parse(buffer, apiVersion);\n            case DESCRIBE_CLUSTER:\n                return DescribeClusterRequest.parse(buffer, apiVersion);\n            case DESCRIBE_PRODUCERS:\n                return DescribeProducersRequest.parse(buffer, apiVersion);\n            case BROKER_REGISTRATION:\n                return BrokerRegistrationRequest.parse(buffer, apiVersion);\n            case BROKER_HEARTBEAT:\n                return BrokerHeartbeatRequest.parse(buffer, apiVersion);\n            case UNREGISTER_BROKER:\n                return UnregisterBrokerRequest.parse(buffer, apiVersion);\n            case DESCRIBE_TRANSACTIONS:\n                return DescribeTransactionsRequest.parse(buffer, apiVersion);\n            case LIST_TRANSACTIONS:\n                return ListTransactionsRequest.parse(buffer, apiVersion);\n            case ALLOCATE_PRODUCER_IDS:\n                return AllocateProducerIdsRequest.parse(buffer, apiVersion);\n            case CONSUMER_GROUP_HEARTBEAT:\n                return ConsumerGroupHeartbeatRequest.parse(buffer, apiVersion);\n            case CONSUMER_GROUP_DESCRIBE:\n                return ConsumerGroupDescribeRequest.parse(buffer, apiVersion);\n            case CONTROLLER_REGISTRATION:\n                return ControllerRegistrationRequest.parse(buffer, apiVersion);\n            case GET_TELEMETRY_SUBSCRIPTIONS:\n                return GetTelemetrySubscriptionsRequest.parse(buffer, apiVersion);\n            case PUSH_TELEMETRY:\n                return PushTelemetryRequest.parse(buffer, apiVersion);\n            case ASSIGN_REPLICAS_TO_DIRS:\n                return AssignReplicasToDirsRequest.parse(buffer, apiVersion);\n            case LIST_CLIENT_METRICS_RESOURCES:\n                return ListClientMetricsResourcesRequest.parse(buffer, apiVersion);\n            case DESCRIBE_TOPIC_PARTITIONS:\n                return DescribeTopicPartitionsRequest.parse(buffer, apiVersion);\n            case SHARE_GROUP_HEARTBEAT:\n                return ShareGroupHeartbeatRequest.parse(buffer, apiVersion);\n            case SHARE_GROUP_DESCRIBE:\n                return ShareGroupDescribeRequest.parse(buffer, apiVersion);\n            case SHARE_FETCH:\n                return ShareFetchRequest.parse(buffer, apiVersion);\n            case SHARE_ACKNOWLEDGE:\n                return ShareAcknowledgeRequest.parse(buffer, apiVersion);\n            case ADD_RAFT_VOTER:\n                return AddRaftVoterRequest.parse(buffer, apiVersion);\n            case REMOVE_RAFT_VOTER:\n                return RemoveRaftVoterRequest.parse(buffer, apiVersion);\n            case UPDATE_RAFT_VOTER:\n                return UpdateRaftVoterRequest.parse(buffer, apiVersion);\n            case INITIALIZE_SHARE_GROUP_STATE:\n                return InitializeShareGroupStateRequest.parse(buffer, apiVersion);\n            case READ_SHARE_GROUP_STATE:\n                return ReadShareGroupStateRequest.parse(buffer, apiVersion);\n            case WRITE_SHARE_GROUP_STATE:\n                return WriteShareGroupStateRequest.parse(buffer, apiVersion);\n            case DELETE_SHARE_GROUP_STATE:\n                return DeleteShareGroupStateRequest.parse(buffer, apiVersion);\n            case READ_SHARE_GROUP_STATE_SUMMARY:\n                return ReadShareGroupStateSummaryRequest.parse(buffer, apiVersion);\n            case STREAMS_GROUP_HEARTBEAT:\n                return StreamsGroupHeartbeatRequest.parse(buffer, apiVersion);\n            case STREAMS_GROUP_DESCRIBE:\n                return StreamsGroupDescribeRequest.parse(buffer, apiVersion);\n            case DESCRIBE_SHARE_GROUP_OFFSETS:\n                return DescribeShareGroupOffsetsRequest.parse(buffer, apiVersion);\n            default:\n                throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `parseRequest`, the \" +\n                        \"code should be updated to do so.\", apiKey));\n        }\n    }\n}\n"
    }
  }
}